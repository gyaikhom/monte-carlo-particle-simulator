@q This file is part of the Monte Carlo Simulator (c) Cardiff University 2011 @>

@** Simulation. The particle simulations are carried out in batches of.

After a simulation has begun, it will only exit under two conditions:

1) All of the particles have been processed. This includes all of the
primary particles generated by the particle gun, and all of the
secondary particles generated by physics processes.

2) There was an error while processing the particles. There are
several causes for error, for instance, there is not enough space to
accommodate the heap expansion required for adding secondary
particles, etc.

@*1 Particle.
A {\sl particle}@^particle@> is the lowest-level data structure that
\.{MCS} manipulates. This data structure represents a fundamental
particle in physics, which interacts with the materials in the
world.

In \.{MCS}, all of the primary particles to be simulated are generated
by the particle gun. The origin of these particles are specified by the
vertex used by the particle gun. A particle gun can generate particles
from various vertices.

@<Type definitions@>=
struct particle_struct {
       @<Physical properties of a particle @>;
       @<Auxilliary data for managing a particle@>;
};

@ These are the properties used by the physics processes.

@<Physical properties of a particle @>=
Vector v; /* position */
Vector mo; /* momentum */
Vector po; /* polarisation */
double m; /* mass */
double c; /* charge */

@ Every particle knows which subcuboid it is currently inside. It also
maintains a unique identifier, which is supplied by the particle
repository. Finally, to determine the particle hierarchy, each
particle also maintains the identifier of its parent and a sibling
index, which ranks the children of a particle.

@<Auxilliary data for managing a particle@>=
uint32_t subcuboid; /* index of subcuboid containing particle */
uint32_t id; /* particle identifier */
uint32_t pi; /* parent identifier */
uint16_t si; /* sibling index (rank among siblings) */
uint16_t nd; /* number of daughter particles */
uint8_t s; /* the $s$-field */
bool active; /* is the particle active (to be simulated) */

@ @<Print particle information to |stdout|@>=
fprintf(stdout, "%u (%lf, %lf, %lf) %u (%lf, %lf, %lf) "
		"(%lf, %lf, %lf) %lf %lf %u %u %u\n",
	p->id, p->v[0], p->v[1], p->v[2], p->s,
	p->mo[0], p->mo[1], p->mo[2],
	p->po[0], p->po[1], p->po[2],
	p->m, p->c, p->pi, p->si, p->nd);

@*1 Vertex.
To generate particles, a particle gun must first be placed inside the
world by choosing a vertex. When the particle gun is activated,
primary particles are generated from this vertex. A vertex is not
associated with a particle gun, however; they are stored with respect
to an event. Hence, an event can have multiple vertices associated
with it. These are stored as a linked-list.

@f uint32_t int
@<Type definitions@>=
typedef struct vertex_struct {
       Vector v; /* particle gun position vector */
       Vector mo; /* momentum */
       Vector po; /* polarisation */
       double e; /* energy */
       double c; /* charge */
       uint32_t np; /* number of particles required */
       struct vertex_struct *next;
} Vertex;

@ Function |create_vertex(e)| creates a new vertex under the supplied
event |e|. This functions returns a pointer to the vertex, or |NULL|
if a new vertex could not be created.

@d vertices_per_block 10 /* TODO: */
@<Global functions@>=
static Vertex *next_vertex = NULL;
static Vertex *bad_vertex = NULL;
Vertex *create_vertex(Event *e)
{
        Vertex *v = next_vertex;
	if (v == bad_vertex) {
	   v = mem_typed_alloc(vertices_per_block, Vertex, mem_p);
	   if (NULL == v) return NULL;
	   else {
	   	next_vertex = v + 1;
		bad_vertex = v + vertices_per_block;
	   }
	} else ++next_vertex;
	@<Insert vertex to event@>;
        return v;
}

@ @<Insert vertex to event@>=
e->nv++;
v->next = e->v;
e->v = v;

@*1 Events.
An {\sl event}@^event@> is the highest-level simulation object. It
provides a link between the user and the simulator. Users specify the
number of events they wish to simulate. An event is associated with
various vertices which specify the locations where a particle gun
could be placed. To generate primary particles, the particle gun must
first be placed on one of the vertices of the event being simulated.

@<Type definitions@>=
typedef struct event_struct {
       uint32_t id; /* event identifier */
       uint32_t nv; /* number of vertices */
       Vertex *v; /* head of the vertex linked list */
       struct event_struct *next; /* pointer to next event */
} Event;

@ Function |create_event()| creates a new event with a unique
identifier. This functions returns a pointer to the event, or |NULL|
if a new event could not be created.

@d events_per_block 10 /* TODO: */
@<Global functions@>=
static Event *next_event = NULL;
static Event *bad_event = NULL;
static uint32_t next_event_id = 0;
Event *create_event()
{
        Event *e = next_event;
	if (e == bad_event) {
	   e = mem_typed_alloc(events_per_block, Event, mem_p);
	   if (NULL == e) return NULL;
	   else {
	   	next_event = e + 1;
		bad_event = e + events_per_block;
	   }
	} else ++next_event;
	e->id = ++next_event_id;
        return e;
}

@*1 Particle gun.


@*1 Batch simulation.

@ All of the particles that are currently processed as primaries are
stored starting from the left-hand side of the particles array. The
generated secondary particles, on the other hand, are stored starting
from the right-hand side of the particle array. 

@d MAX_PRIMARIES_BLOCK 16 /* must depend on available memory */
@d MAX_DAUGHTERS 10 /* maximum number of daughters allowed */
@d MAX_SECONDARIES_BLOCK (MAX_DAUGHTERS * MAX_PRIMARIES_BLOCK)
@<Type definitions@>=
typedef struct block_struct {
	uint32_t np; /* number of primaries */
	uint32_t ns; /* number of secondaries */
	uint32_t subcuboid; /* index of the associated subcuboid */
	Particle p[MAX_PRIMARIES_BLOCK];
	Particle s[MAX_SECONDARIES_BLOCK];
} Block;

@
@d MAX_BLOCKS_BATCH 10 /* must depend on available compute blocks */
@<Type definitions@>=
typedef struct sim_batch_struct {
	uint32_t n; /* number of blocks with particles in them */
	Block b[MAX_BLOCKS_BATCH]; /* array of blocks */
} Batch;


@ Function |generate_primaries()| fills up the particle repository
with primary partices generated using a particle gun. The aim is to
fill up the max-heap, without expanding the heap, so that all of the
particles required by all of the vertices in all of the events are
processed.

@<Global functions@>=
int generate_primaries()
{
	static uint32_t call_count = 0;
    Particle p; /* primary particle to be generated */
    int n = 0; /* number of particles generated in this call */
    fprintf(stderr, "\ngp: %u\n", call_count++);
    while (ge) {
        while (gv) {
             while (gc < gv->np) {
	         if (heap_has_space(particles)) {
                     @<Generate primary particle using particle gun@>;
   		     heap_insert(&particles, &p, false);
   		     ++n;
   		     ++gc;
		 } else goto heap_is_full;
             }
	     gv = gv->next; /* move to the next vertex */
	     gc = 0;
	}
	ge = ge->next; /* move to the next event */
	if (ge) {
	    gv = ge->v;
	    gc = 0;
	}
    }
    heap_is_full:
    return n;
}

@ During multiple calls to |generate_primaries()|, we maintain from
one call to the next the index of the current event, the index of the
current vertex within that event, and the number of particles already
generated for the current vertex, using global variables.

@<Global variables@>=
Event *ge = NULL; /* current simulation event */
Vertex *gv = NULL; /* current vertex within simulation event */
uint32_t gc = 0; /* current particle count for current vertex */

@ @<Generate primary particle using particle gun@>=
vector_zero(p.v);
vector_zero(p.mo);
vector_zero(p.po);
p.m = p.c = 0.0;
p.id = p.pi = p.si = 0;
p.active = true; /* only active particles inside heap */
p.s = 0x0; /* renew: $s$-field are changed by physics processes */
p.nd = 0; /* no daughters yet */
p.subcuboid = find_subcuboid(subcuboid_search_tree, p.v);

fprintf(stderr, "*");

@ Function |get_particle(p)| retrieves a particle from the particle
repository and stores the particle in |p|. It returns 1 if a particle
was retrieved successfully; otherwise, returns 0.

If there are not particles in the particles repository, it will
attempt to fill the particles repository by generating primary
particles using the particle gun.

@<Global functions@>=
int get_particle(Particle *p)
{
	if (HEAP_EMPTY == heap_remove(&particles, p)) {
	    if (generate_primaries())
	        heap_remove(&particles, p); /* try again */
	    else return 0; /* no more particles left */
	}
	return 1; /* one particle retrieved */
}


@ Function |create_batch(b)| creates a simulation batch and stores the
batch in |b|. If successful, it returns a positive number that gives
the number of particles in the batch; otherwise, it returns a negative
value which gives an error code.

Each simulation batch comprises of several data blocks that
contain information about the particles and the subcuboid which
contains those particles. Each of these blocks will be processed
exclusively by one of the compute blocks, which could have multiple
threads in them.

The batch is created by starting at the first slot of the first
block. We continue filling each slot in each of the blocks by taking
particles from the particle repository, until all of the blocks are
full. Furthermore, since all of the particles must be contained by 
the same subcuboid, we also move forward to the next block when the
particle retrieved from the particle repository has a smaller
subcuboid index. Because the particle repository is implemented as a
max-heap, where the subcuboid index is used as a comparison key, the
|get_particle()| call will never return a particle with subcuboid index
greater than the subcuboid index of the current block. The blocks,
therefore, effectively group the particles that belong in the same
subcuboid.

@<Global functions@>=
int create_batch(Batch *b)
{
static uint32_t call_count = 0;
	Particle p; /* particle retrieved from heap */
	uint32_t n; /* number of particles in batch */
	uint32_t i, j; /* current block, and current slot within block */
	i = j = 0; /* start at first slot of first block */
	b->n = n = 0; /* reset block and particle count */
	fprintf(stderr, "\ncb: %u\n", call_count++);
	if (get_particle(&p)) {
	    b->b[i].subcuboid = p.subcuboid; /* subcuboid index for the block */
	    b->b[i].p[j++] = p; /* add particle to block */
	    b->n++; /* increment number of active blocks */
	    ++n;
	    fprintf(stderr, "block %u: %u\n", i, p.id);
	    while (get_particle(&p)) {
	        if (b->b[i].subcuboid != p.subcuboid ||
		    MAX_PRIMARIES_BLOCK == j) { /* change block */
		    b->b[i].np = j; /* finalise current block */
		    b->b[i].ns = 0;
		    if (MAX_BLOCKS_BATCH == ++i) { /* move to next block */
		        heap_insert(&particles, &p, false); /* batch is full: retain particle for next batch */
		        goto batch_is_full;
		    }
		    b->b[i].subcuboid = p.subcuboid; /* subcuboid index for the new block */
                    b->n++; /* increment number of active blocks */
		    j = 0; /* first slot of new block */
	        }
	        b->b[i].p[j++] = p; /* add particle to block */
		++n;
		fprintf(stderr, "block %u: %u\n", i, p.id);
	    }
    	    b->b[i].np = j; /* finalise current block */
	    b->b[i].ns = 0;
    	}
batch_is_full:
	return n;
}

@ @<Global functions@>=
int simulate_batch(Batch *b)
{
	uint32_t i = 0, j, k;
	while(i < b->n) {
	    j = 0;
	    k = 0;
	    while(j < b->b[i].np) {
		fprintf(stderr, "%3u ", b->b[i].p[j].id);
	        b->b[i].s[k] = b->b[i].p[j];
		b->b[i].s[k].active = false;
		++j;
		++k;
	    }
	    b->b[i].ns = k;
	    b->b[i].np = 0;
	    fprintf(stderr, "%u\n", b->b[i].ns);

	    ++i;
	}
	return 0;
}

@ @<Global functions@>=
Particle gpbuff[MAX_STORE_BUFFER];
uint32_t gpbuffsize = 0;
FILE *gpfile = NULL;
void flush_particles()
{
	uint32_t i;
	for (i = 0; i < gpbuffsize; ++i) @<Print particle information to |gpfile|@>;
	gpbuffsize = 0;
}

@ @<Print particle information to |gpfile|@>=
fprintf(gpfile, "%u (%lf, %lf, %lf) %u (%lf, %lf, %lf) "
		"(%lf, %lf, %lf) %lf %lf %u %u %u\n",
	gpbuff[i].id, gpbuff[i].v[0], gpbuff[i].v[1], gpbuff[i].v[2], gpbuff[i].s,
	gpbuff[i].mo[0], gpbuff[i].mo[1], gpbuff[i].mo[2],
	gpbuff[i].po[0], gpbuff[i].po[1], gpbuff[i].po[2],
	gpbuff[i].m, gpbuff[i].c, gpbuff[i].pi, gpbuff[i].si, gpbuff[i].nd);

@
@d MAX_STORE_BUFFER 60 /* number of particles in output buffer */
@<Global functions@>=
int store_particle(Particle *p)
{
	if (gpbuffsize == MAX_STORE_BUFFER) flush_particles();
	gpbuff[gpbuffsize++] = *p;
	return 0;
}

@ Function |update_repository(b)| updates the particle repository
following a successful batch simulation by moving primary and
secondary particles from the active blocks in the batch to the
max-heap.

@<Global functions@>=
int update_repository(Batch *b)
{
    int i, j;
    Particle p;
    for (i = 0; i < b->n; ++i) {
	@<Move unprocessed primary particles to repository@>;
        @<Move secondary particles to repository@>;
    }
    return 0;
}

@ @<Move unprocessed primary particles to repository@>=
fprintf(stderr, "mp: %u, ", b->b[i].np);
for (j = 0; j < b->b[i].np; ++j)
    heap_insert(&particles, &b->b[i].p[j], true);

@ @<Move secondary particles to repository@>=
fprintf(stderr, "ms: %u\n", b->b[i].ns);
for (j = 0; j < b->b[i].ns; ++j) {
    p = b->b[i].s[j];
    if (p.active) {
        @<Update subcuboid for active primaries and generated secondaries@>;
        heap_insert(&particles, &p, true);
    } else store_particle(&p); /* write to disk */
}

@ @<Update subcuboid for active primaries and generated secondaries@>=
update_sfield(&(p.s), &(subcuboids[p.subcuboid].bb), p.v);
p.subcuboid = get_neighbour(p.subcuboid, p.s);
p.s = 0x0; /* renew: $s$-field are changed by physics processes */

@ Function |run_simulation()| runs the simulation iteratively by 
creating and simulating batches in each iteration, until all of the
particles, both primary and secondary, have been processed. It returns
0 if the simulation was a success; otherwise, a non-zero value is returned.
@<Global functions@>=
int run_simulation()
{
	int i, j = 0;
	Batch b;
        fprintf(stderr, "Batch: %d\n", j++);
	while ((i = create_batch(&b))) {
	    if (i < 0) goto handle_error;
	    if (simulate_batch(&b)) goto handle_error;
	    else if (update_repository(&b)) goto handle_error;
	    fprintf(stderr, "Batch: %d\n", j++);
	}
	return 0; /* simulation done */

handle_error:
	fprintf(stderr, "Error\n");
	return 1;
}

@ @<Test simulation batch@>=
{
	Event *e, *ee;
	Vertex *v, *vv;

	/* first event */
	ee = create_event();
	vv = create_vertex(ee); vv->np = 15;
	v = create_vertex(ee); v->np = 25;
	v = create_vertex(ee); v->np = 15;
	v = create_vertex(ee); v->np = 25;

	/* second event */
	e = create_event();
	v = create_vertex(e); v->np = 15;
	v = create_vertex(e); v->np = 25;
	v = create_vertex(e); v->np = 15;
	v = create_vertex(e); v->np = 25;	
	e->next = ee;
	ee = e;

	/* third event */
	e = create_event();
	v = create_vertex(e); v->np = 45;
	v = create_vertex(e); v->np = 35;
	v = create_vertex(e); v->np = 25;
	v = create_vertex(e); v->np = 15;	
	e->next = ee;
	ee = e;

	e = ee;
	while (e) {
	    v = e->v;
	    while (v) {
	        fprintf(stderr, "%u %u\n", e->id, v->np);
	        v = v->next;
	    }
	    e = e->next;
	}
	gpfile = stdout;
	BoundingBox bb = {{100.0, 100.0, 1000.0, 1.0},{0.0, 0.0, 0.0, 1.0}};
	build_subcuboid_trees(&bb, 4, 4, 4);
	heap_init(&particles);
	ge = ee;
	if (ge) {
	    gv = ge->v;
	    gc = 0;
        }
	run_simulation();
	flush_particles();
}
