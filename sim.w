@q This file is part of the Monte Carlo Simulator (c) Cardiff University 2011 @>

@** Simulation. This section defines data-structures and functions for
representing and manipulating particles, events and simulations.

@*1 Particle.
A {\sl particle}@^particle@> is the lowest-level data structure that
\.{MCS} manipulates. This data structure represents a fundamental
particle in physics, which interacts with the materials in the
world.

Every particle has a {\sl position}@^position@>, which is given by a
three-dimensional vector. This position is defined relative to the
origin of the {\sl world} coordinate system. Particles also have
{\sl mass}@^mass@>, and {\sl charge}@^charge@>.

In \.{MCS}, all of the particles to be simulated are generated by the
particle gun, and the origin of these particles are specified by the
vertex used by the particle gun. A particle gun can generate particles
from various vertices. We stored all of the particles generated from a
given vertex as a linked-list. Hence, |next| points to the next
particle in this list; |next = NULL| for the last particle in the
list. Furthermore, during particle-matter interactions, new particles
may be generated. These secondary particles are considered {\it
daughter particles}@^daughter particle@>, and are stored as a
linked-list. The pointer |daughter| points to the head of this linked
list.

@<Type definitions@>=
struct particle_struct {
        Vector momentum;
        double mass;  
      	double charge;
      	Vector polarisation;
	uint32_t num_daughters;
	uint32_t subcuboid;
      	struct particle_struct *next;
      	struct particle_struct *daughters;
};

@ Function |create_particle| creates a new particle and returns a
valid particle, or |NULL| if a new particle cannot be created.

@<Global functions@>=
Particle *create_particle(Vertex *v)
{
	Particle *p = (Particle *) malloc(sizeof(Particle));
	if (p) {
	        @<Initialise new particle@>;
		@<Add new particle to the generating vertex@>;
	}
	return p;
}

@ @<Initialise new particle@>=
p->num_daughters = 0;
p->daughters = NULL;

@ @<Add new particle to the generating vertex@>=
p->next = v->particles;
v->particles = p;
v->num_particles++;

@ Function |destroy_particle| destroys a particle and all of its
daughters.

@<Global functions@>=
void destroy_particle(Particle *p)
{
	Particle *t;
	if (NULL == p) return;
	while (p->daughters) {
	        t = p->daughters->next;
		destroy_particle(p->daughters);
		p->daughters = t;
	}
	free(p);
}

@ Print a primary including all of its secondary particles.

@<Global functions@>=
void print_particle(Particle *p)
{
	Particle *t;
	if (NULL == p) return;
	@<Print particle information@>;
	@<Print daughter particles@>;
}

@ @<Print particle information@>=

@ @<Print daughter particles@>=
t = p->daughters;
while (t) {
	print_particle(t);
	t = t->next;
}

@ @<Generate primary particles@>=
for (k = 0; k < num_particles; k++) {
        current_particle = create_particle(current_vertex);
	if (NULL == current_particle) {
	        fatal("failed to create particle");
		@<Simulation has failed! Exit application@>;
	}
}


@*1 Vertex.
To generate particles, a particle gun must first be placed inside the
world by choosing a vertex. When the particle gun is activated,
primary particles are generated from this vertex. A vertex is not
associated with a particle gun, however; they are stored with respect
to an event. Hence, an event can have multiple vertices associated
with it. These are stored as a linked-list.

@f uint32_t int
@<Type definitions@>=
struct vertex_struct {
       Vector position;
       uint32_t num_particles;
       Particle *particles;
       struct vertex_struct *next;
};
typedef struct vertex_struct Vertex;

@ Function |create_vertex| creates a new vertex, and associates the
vertex with the supplied event. This functions returns a pointer to
the vertex, or |NULL| if a new vertex could not be created.

@<Global functions@>=
Vertex *create_vertex(Event *e)
{
	Vertex *v = (Vertex *) malloc(sizeof(Vertex));
	if (v) {
	        v->particles = NULL;
	        v->num_particles = 0;
	        v->next = e->vertices;
	        e->vertices = v;
	        e->num_vertices++;
	}
	return v;
}

@ Function |destroy_vertex| destroys the vertex by destroying all of
the particles associated with it.

@<Global functions@>=
void destroy_vertex(Vertex *v)
{
	Particle *t;
	if (NULL == v) return;
	while (v->particles) {
	        t = v->particles->next;
		destroy_particle(v->particles);
	        v->particles = t;	
	}
	free(v);
}

@ Print a vertex with all of its primary and secondary particles.

@<Global functions@>=
void print_vertex(Vertex *v)
{
	if (NULL == v) return;
	@<Print vertex information@>;
	@<Print particles@>;
}

@ @<Print vertex information@>=
fprintf(stdout, "\tVertex has %d primary particles\n", v->num_particles);

@ @<Print particles@>=
current_particle = v->particles;
while (current_particle) {
        print_particle(current_particle);
	current_particle = current_particle->next;
}

@ @<Generate vertices@>=
for (j = 0; j < num_vertices; j++) {
        current_vertex = create_vertex(current_event);
	if (NULL == current_vertex) {
	        fatal("failed to create vertex");
		@<Simulation has failed! Exit application@>;
	}
	@<Generate primary particles@>;
}

@*1 Particle gun.

@<Type definitions@>=
struct particle_gun_struct {
       uint32_t num_particles; /* no. particles to generate */
       Vector position; /* vertex position */
       Vector momentum;
       Vector polarisation;
       double energy;
       double charge;
};
typedef struct particle_gun_struct Particle_gun;

@ There should be only one particle gun.

@<Global functions@>=
void reset_particle_gun()
{
        particle_gun.num_particles = 0;
	vector_zero(particle_gun.position);
	vector_zero(particle_gun.momentum);
	vector_zero(particle_gun.polarisation);
	particle_gun.energy = 0.0;
	particle_gun.charge = 0.0;
}

@ All of the particles generated from a vertex will have the same
physical quantities as currently defined by the particle gun 
parameters. Hence, before generating a vertex, the particle gun must
be initialised with the required parameters by invoking the
corresponding |set_pg_*| functions. To generate particles with different
physical quantities, different vertices must be generated after
initialising the particle gun parameters as required.

@ The number of particles to be generated with each activation of the
particle gun. Set num particles to be generated by particle gun.

@<Global functions@>=
void set_pg_num_particles(uint32_t n)
{
	particle_gun.num_particles = n;
}

@ Set position of particle gun.
@<Global functions@>=
void set_pg_position(Vector position)
{
	vector_copy(particle_gun.position, position);
}

@ Set momentum of particle gun.
@<Global functions@>=
void set_pg_momentum(Vector momentum)
{
	vector_copy(particle_gun.momentum, momentum);
}

@ Set polarisation of particle gun.
@<Global functions@>=
void set_pg_polarisation(Vector polarisation)
{
	vector_copy(particle_gun.polarisation, polarisation);
}

@ Set energy of particle gun.
@<Global functions@>=
void set_pg_energy(double energy)
{
	particle_gun.energy = energy;
}

@ Set charge of particle gun.
@<Global functions@>=
void set_pg_charge(double charge)
{
	particle_gun.charge = charge;
}

@*1 Events.
An {\sl event}@^event@> is the highest-level simulation object. It
provides a link between the user and the simulator. Users specify the
number of events they wish to simulate. An event is associated with
various vertices which specify the locations where a particle gun
could be placed. To generate primary particles, the particle gun must
first be placed on one of the vertices of the event being simulated.

@<Type definitions@>=
struct event_struct {
       uint32_t id; /* event identifier */
       uint32_t num_vertices;
       Vertex *vertices;
};
typedef struct event_struct Event;

@ Create event.
@<Global functions@>=
Event *create_event(uint32_t id)
{
	Event *e = (Event *) malloc(sizeof(Event));
	if (e) {
	        e->id = id;
		e->num_vertices = 0;
		e->vertices = NULL;
	}
	return e;
}

@ Destroy event.
@<Global functions@>=
void destroy_event(Event *e)
{
	Vertex *v;
	if (NULL == e) return;
	while (e->vertices) {
	      v = e->vertices->next;
	      destroy_vertex(e->vertices);
	      e->vertices = v;
	}
	free(e);
}

@ Print event information, which is a tree with all of the vertices, primary
particles, and secondary daughter particles.

@<Global functions@>=
void print_event(Event *e)
{
	if (NULL == e) return;
	@<Print event information@>;
	@<Print vertices@>;
}

@ @<Print event information@>=
fprintf(stdout, "Event %2d\n", e->id);
fprintf(stdout, "Number of vertices: %2d\n", e->num_vertices);

@ @<Print vertices@>=
current_vertex = e->vertices;
while (current_vertex) {
        print_vertex(current_vertex);
	current_vertex = current_vertex->next;
}

@ To simulate an event, we first create an event object. Then, we
invoke generate the vertices and the required primary particles.

@<Simulate $i$th event@>=
current_event = create_event(i);
if (NULL == current_event) {
        fatal("failed to create event");
	@<Simulation has failed! Exit application@>;
}
@<Generate vertices@>;
print_event(current_event);
@<Simulate the event@>;
destroy_event(current_event);

@*1 User specified.

@<Set particle gun parameters@>=

@*1 Running the simulation.

We use the stack data structure for simulating an event. Before the
simulation begins, all of the primary particles associated with the
event are pushed into the {\sl particle stack}@^particle stack@>. Then, we track the particles in the stack until the stack is
empty.

@d MAX_STACK_SIZE 4096
@<Type definitions@>=
struct particle_stack_struct {
       uint32_t tos; /* top of stack */
       Particle *particles[MAX_STACK_SIZE];
};
typedef struct particle_stack_struct Particle_stack;

@ @<Clear the particle stack@>=
particle_stack.tos = 0;

@ Push particle into particle stack.
@<Global functions@>=
void push_particle(Particle *p)
{
	if (MAX_STACK_SIZE == particle_stack.tos) return;
	particle_stack.particles[particle_stack.tos++] = p;
}

@ Pop particle out of the particle stack.
@<Global functions@>=
Particle *pop_particle()
{
	if (0 == particle_stack.tos) return NULL;
	return particle_stack.particles[--particle_stack.tos];
}

@ @<Simulate the event@>=
@<Fill in the particle stack for this event@>;
@<Process the particle stack@>;

@ @<Fill in the particle stack for this event@>=
@<Clear the particle stack@>;
current_vertex = current_event->vertices;
while (current_vertex) {
        current_particle = current_vertex->particles;
        while (current_particle) {
	        push_particle(current_particle);
	        current_particle = current_particle->next;
	}
        current_vertex = current_vertex->next;
}

@ @<Process the particle stack@>=
while ((current_particle = pop_particle())) {
      track_particle();
}

@ @<Simulation has failed! Exit application@>=

@*1 Tracking a particle.

@<Global functions@>=
void track_particle()
{
	fprintf(stdout, "traking a particle");
}
