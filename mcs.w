@** Introduction.
The {\it Monte Carlo Simulator}, \.{MCS} in short, is a simulation
package for high-energy physics. It uses Monte Carlo techniques for
the randomised simulation of particle interactions. The system borrows
concepts defined in the Geant4 system; however, they have been
reimplemented using ANSI \CEE/ using new data structures and
algorithms.

@* Overview.
The \.{MCS} system is in effect an event processor. The user specifies
the number of events they wish to simulate, and provides the system
with the necessary details to process each of the events. These
details include procedures and data for generating the particles for
each event, and the {\it physics processes}@^physics processes@>
required by the type of the particle being simulated and the
properties of the materials involved in each of the interactions. We
are only interested in interactions that are happening inside a closed
three-dimensional system, referred to as the {\it
world}@^world@>. Since the world is defined by the components present,
the user must provide the geometry of the components in addition to
the properties of the materials the components are made of. In this
document, these input data will be referred to {\it simulation
parameters}@^simulation parameters@>.

Once the \.{MCS} system is supplied with a valid set of simulation
parameters, it processes the geometries and creates a data structure
that allows efficient location of an interaction point. This is an
important step because, to process a large number of interactions
rapidly, we must efficiently find the location inside the world where
the interactions are happening, as it determines the materials
required by the processes.

We then define the {\it particle gun}@^particle gun@>, which generates
the required number of {\it primary particles}@^primary particles@>
for each of the events. Primary particles are particles that are
generated explicitly by a particle gun, and {\it secondary
particles}@^secondary particles@> are those that are generated as a
result of particle-matter interaction. Since multiple primary
particles may be generated by an event, a {\it vertex}@^vertex@> is
defined for each event. For any given event the associated vertex
provides the location of the particle gun, so that all of the
particles generated originates from this location. When the particle
gun is activated, a set of primary particles are generated. These
particles have the same origin, as defined by the vertex location,
however, they carry different properties, such as energy, momentum,
etc. These values are set using a {\it random number
generator}@^random number generator@>.

Once a particle has been generated, it travels through the materials
until it either comes to a stop, or exits the closed three-dimensional
world. Throughout this journey, the {\it trajectory}@^trajectory@> of
the particle changes depending on its interaction with the
materials. Hence, the \.{MCS} system uses a {\it tracker}@^tracker@>
to track each of the particles throughout its journey.
A snapshot of the particle in its trajectory is referred to as a
{\it track}@^track@>, and is processed independently of any previous
tracks. In other words, a track does not remember its past. Hence, to
keep a record of the trajectory, the tracker records old tracks as new
ones are derived. Each of these points on the trajectory is referred
to as the {\it step point}@^step point@>, and the process of moving to
the next step point as {\it stepping}@^stepping@>. Hence, we invoke
multiple stepping commands to chart the entire trajectory of a
particle.

To move a particle from one track to the next, each stepping decides
the length with which the particle must progress. This is referred to
as a {\it step}@^step@>. Each step has a start point and an end
point. These points store information for retrieving the material
properties that are required by each of the physics processes that are
valid in that stepping. The length of a step is determined by the
process which requires the shortest space-time {\it interaction
length}@^interaction length@>. In other words, the next track must be
located in space-time so that all of the valid physics processes are
applicable.

We use a {\it stack}@^stack@> to store all of the unprocessed
particles, both primary and secondary. At the beginning of each event,
each of the primary particles generated by the particle gun are first
converted to a track, so that the tracker can process them. Then, the
tracks are all pushed into the {\it track stack}@^track stack@>. This
stack is then passed to the tracker, which continuously pops a track
from the track stack and charts the particle's trajectory. If
secondary particles are generated as a result of an interaction, these
are first converted to a track, and then pushed into the track
stack. In other words, if we consider the entire simulation as a tree,
where the root of the tree represents the particle gun, the nodes
represent the particle-matter interactions, and the leaves represent
interactions which resulted in the particle to either stop, or exit
the closed three-dimensional world, then the tracker is simply
undergoing a {\it depth-first tree traversal}@^depth-first traversal@>.

@** The main program.

@p
@<Include system libraries@>@/
@<Global data structures@>@/
@<Global variables@>@/
@<Global functions@>@/
@<Start application@>@/

@ @<Start application@>=
int main(int argc, char *argv[])
{
	@<Parse command line arguments@>;
	@<Process input files@>;
	@<Create physics tables@>;
	@<Create and process events@>;
	@<Clean up the system@>;
	return 0;
}

@ @<Parse command line arguments@>=

@ @<Process input files@>=

@ @<Create physics tables@>=

@ @<Create and process events@>=
for (i = 0; i < num_events; i++) {
	@<Simulate $i$th event@>;
}

@ @<Clean up the system@>=

@** Vectors.

@<Definition of a three-dimensional vector@>=
struct vect3d_struct {
       double x, y, z;
};
typedef struct vect3d_struct vect3d;

@ @<Calculate vector magnitude@>=
double vect3d_magnitude(vect3d *v)
{
	return sqrt(v->x * v->x +
		    v->y * v->y +
		    v->z * v->z);
}

@ @<Normalise a vector@>=
vect3d vect3d_normalize(vect3d *v)
{
	vect3d t;
	double m = vect3d_magnitude(v);
	if (m > 0.0) {
		t.x = v->x / m;
		t.y = v->y / m;
		t.z = v->z / m;
	} else {
		t.x = 0.0;
		t.y = 0.0;
		t.z = 0.0;
	}
	return t;
}

@** Particle.
A {\it particle}@^particle@> is the lowest-level data structure that
\.{MCS} manipulates. This data structure represents a fundamental
particle in physics, which interacts with the materials in the
world.

Every particle has a {\it position}@^position@>, which is given by a
three-dimensional vector. This position is defined relative to the
origin of the {\it world} coordinate system. Particles also have
{\it mass}@^mass@>, and {\it charge}@^charge@>.

In \.{MCS}, all of the particles to be simulated are generated by the
particle gun, and the origin of these particles are specified by the
vertex used by the particle gun. A particle gun can generate particles
from various vertices. We stored all of the particles generated from a
given vertex as a linked-list. Hence, |next| points to the next
particle in this list; |next = NULL| for the last particle in the
list. Furthermore, during particle-matter interactions, new particles
may be generated. These secondary particles are considered {\it
daughter particles}@^daughter particle@>, and are stored as a
linked-list. The pointer |daughter| points to the head of this linked
list.

@<Definition of a particle@>=
struct particle_struct {
        vect3d position;
        double mass;  
      	double charge;
      	vect3d polarisation;
	uint32_t num_daughters;
      	struct particle_struct *next;
      	struct particle_struct *daughters;
};
typedef struct particle_struct particle;

@ Function |create_particle| creates a new particle and returns a
valid particle, or |NULL| if a new particle cannot be created.

@<Create a new particle@>=
particle *create_particle(vertex *v)
{
	particle *p = (particle *) malloc(sizeof(particle));
	if (p) {
	        @<Initialise new particle with the default values@>;
		@<Add new particle to the generating vertex@>;
	}
	return p;
}

@ @<Initialise new particle with the default values@>=
p->position.x = v->position.x;
p->position.y = v->position.y;
p->position.z = v->position.z;
p->num_daughters = 0;
p->daughters = NULL;

@ @<Add new particle to the generating vertex@>=
p->next = v->particles;
v->particles = p;
v->num_particles++;

@ Function |destroy_particle| destroys a particle and all of its
daughters.

@<Destroy particle@>=
void destroy_particle(particle *p)
{
	particle *t;
	if (p == NULL) return;
	while (p->daughters) {
	        t = p->daughters->next;
		destroy_particle(p->daughters);
		p->daughters = t;
	}
	free(p);
}

@ @<Generate primary particles@>=
for (k = 0; k < num_particles; k++) {
        current_particle = create_particle(current_vertex);
	if (current_particle == NULL) {
	        fatal("failed to create particle");
		@<Simulation has failed! Exit application@>;
	}
}


@** Vertex.
To generate particles, a particle gun must first be placed inside the
world by choosing a vertex. When the particle gun is activated,
primary particles are generated from this vertex. A vertex is not
associated with a particle gun, however; they are stored with respect
to an event. Hence, an event can have multiple vertices associated
with it. These are stored as a linked-list.

@f uint32_t int
@<Definition of a vertex@>=
struct vertex_struct {
       vect3d position;
       uint32_t num_particles;
       particle *particles;
       struct vertex_struct *next;
};
typedef struct vertex_struct vertex;

@ Function |create_vertex| creates a new vertex, and associates the
vertex with the supplied event. This functions returns a pointer to
the vertex, or |NULL| if a new vertex could not be created.

@<Create a new vertex@>=
vertex *create_vertex(event *e)
{
	vertex *v = (vertex *) malloc(sizeof(vertex));
	if (v) {
	        v->particles = NULL;
	        v->num_particles = 0;
	        v->next = e->vertices;
	        e->vertices = v;
	        e->num_vertices++;
	}
	return v;
}

@ Function |destroy_vertex| destroys the vertex by destroying all of
the particles associated with it.

@<Destroy vertex@>=
void destroy_vertex(vertex *v)
{
	particle *t;
	if (v == NULL) return;
	while (v->particles) {
	        t = v->particles->next;
		destroy_particle(v->particles);
	        v->particles = t;	
	}
	free(v);
}

@ @<Generate vertices@>=
for (j = 0; j < num_vertices; j++) {
        current_vertex = create_vertex(current_event);
	if (current_vertex == NULL) {
	        fatal("failed to create vertex");
		@<Simulation has failed! Exit application@>;
	}
	@<Generate primary particles@>;
}

@** Events.
An {\it event}@^event@> is the highest-level simulation object. It
provides a link between the user and the simulator. Users specify the
number of events they wish to simulate. An event is associated with
various vertices which specify the locations where a particle gun
could be placed. To generate primary particles, the particle gun must
first be placed on one of the vertices of the event being simulated.

@<Definition of an event@>=
struct event_struct {
       uint32_t id; /* event identifier */
       uint32_t num_vertices;
       vertex *vertices;
};
typedef struct event_struct event;

@ @<Create an event with the specified identifier@>=
event *create_event(uint32_t id)
{
	event *e = (event *) malloc(sizeof(event));
	if (e) {
	        e->id = id;
		e->num_vertices = 0;
		e->vertices = NULL;
	}
	return e;
}

@ @<Destroy an event@>=
void destroy_event(event *e)
{
	vertex *v;
	if (e == NULL) return;
	while (e->vertices) {
	      v = e->vertices->next;
	      destroy_vertex(e->vertices);
	      e->vertices = v;
	}
	free(e);
}

@ To simulate an event, we first create an event object. Then, we
invoke generate the vertices and the required primary particles.

@<Simulate $i$th event@>=
current_event = create_event(i);
if (current_event == NULL) {
        fatal("failed to create event");
	@<Simulation has failed! Exit application@>;
}


@<Generate vertices@>;
@<Simulate the event@>;
destroy_event(current_event);

@** Running the simulation.

@ @<Simulate the event@>=

@ @<Simulation has failed! Exit application@>=

@** Error handling.
There are three message categories, which are printed using the
following macros: |fatal|, |warn|, and |info|.

@d fatal(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d warn(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d info(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);

@ @<Include system libraries@>=
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

@ @<Global variables@>=
uint32_t i, j, k, l, m, n; /* counters */
event *current_event = NULL;
vertex *current_vertex = NULL;
particle *current_particle = NULL;
uint32_t num_events;
uint32_t num_vertices;
uint32_t num_particles;

@ @<Global data structures@>=
@<Definition of a three-dimensional vector@>;
@<Definition of a particle@>;
@<Definition of a vertex@>;
@<Definition of an event@>;

@ @<Global functions@>=
@<Calculate vector magnitude@>;
@<Normalise a vector@>;
@<Create a new particle@>;
@<Destroy particle@>;
@<Create a new vertex@>;
@<Destroy vertex@>;
@<Create an event with the specified identifier@>;
@<Destroy an event@>;

@* History.
The {\it Monte Carlo Simulator} project began in June 2011, when
Dr.~Gagarine Yaikhom was a WIMCS Research Fellow under Prof.~David
W. Walker at Cardiff University. The initial aim of the project was to
port the Geant4 system to run on CUDA GPUs. However, after studying
the Geant4 code-base, we concluded that it will be prohibitive to port
the entire Geant4 system given the short duration of the funding (8
months, from June 2011 until January 2012) and that only Dr.~Yaikhom
will be carrying out the design and implementation. We, therefore,
decided to use the Geant4 system only as a guideline system
architecture, and to reimplement the performance-intensive concepts
and their dependencies for a simplified simulator. This
implementation, which began on 5 August 2011, uses data structures
and algorithms that are more appropriate for eventual multithreaded
parallelisation on GPUs.

@**Index.

