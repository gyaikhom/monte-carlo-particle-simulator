@** Introduction.
The {\it Monte Carlo Simulator}, \.{MCS} in short, is a simulation
package for high-energy physics. It uses Monte Carlo techniques for
the randomised simulation of particle interactions. The system borrows
concepts defined in the Geant4 system; however, they have been
reimplemented using ANSI \CEE/ using new data structures and
algorithms with the aim that the system will be ported eventually to GPGPUs.

The \.{MCS} system is in effect an event processor. The user specifies
the number of events they wish to simulate, and provides the system
with the necessary details to process each of the events. These
details include procedures and data for generating the particles for
each event, and the {\it physics processes}@^physics processes@>
required by the type of the particle being simulated and the
properties of the materials involved in each of the interactions. We
are only interested in interactions that are happening inside a closed
three-dimensional system, referred to as the {\it
world}@^world@>. Since the world is defined by the components present,
the user must provide the geometry of the components in addition to
the properties of the materials the components are made of. In this
document, these input data will be referred to {\it simulation
parameters}@^simulation parameters@>.

Once the \.{MCS} system is supplied with a valid set of simulation
parameters, it processes the geometries and creates a data structure
that allows efficient location of an interaction point. This is an
important step because, to process a large number of interactions
rapidly, we must efficiently find the location inside the world where
the interactions are happening, as it determines the materials
required by the processes.

We then define the {\it particle gun}@^particle gun@>, which generates
the required number of {\it primary particles}@^primary particles@>
for each of the events. Primary particles are particles that are
generated explicitly by a particle gun, and {\it secondary
particles}@^secondary particles@> are those that are generated as a
result of particle-matter interaction. Since multiple primary
particles may be generated by an event, a {\it vertex}@^vertex@> is
defined for each event. For any given event the associated vertex
provides the location of the particle gun, so that all of the
particles generated originates from this location. When the particle
gun is activated, a set of primary particles are generated. These
particles have the same origin, as defined by the vertex location,
however, they carry different properties, such as energy, momentum,
etc. These values are set using a {\it random number
generator}@^random number generator@>.

Once a particle has been generated, it travels through the materials
until it either comes to a stop, or exits the closed three-dimensional
world. Throughout this journey, the {\it trajectory}@^trajectory@> of
the particle changes depending on its interaction with the
materials. Hence, the \.{MCS} system uses a {\it tracker}@^tracker@>
to track each of the particles throughout its journey.
A snapshot of the particle in its trajectory is referred to as a
{\it track}@^track@>, and is processed independently of any previous
tracks. In other words, a track does not remember its past. Hence, to
keep a record of the trajectory, the tracker records old tracks as new
ones are derived. Each of these points on the trajectory is referred
to as the {\it step point}@^step point@>, and the process of moving to
the next step point as {\it stepping}@^stepping@>. Hence, we invoke
multiple stepping commands to chart the entire trajectory of a
particle.

To move a particle from one track to the next, each stepping decides
the length with which the particle must progress. This is referred to
as a {\it step}@^step@>. Each step has a start point and an end
point. These points store information for retrieving the material
properties that are required by each of the physics processes that are
valid in that stepping. The length of a step is determined by the
process which requires the shortest space-time {\it interaction
length}@^interaction length@>. In other words, the next track must be
located in space-time so that all of the valid physics processes are
applicable.

We use a {\it stack}@^stack@> to store all of the unprocessed
particles, both primary and secondary. At the beginning of each event,
each of the primary particles generated by the particle gun are first
converted to a track, so that the tracker can process them. Then, the
tracks are all pushed into the {\it track stack}@^track stack@>. This
stack is then passed to the tracker, which continuously pops a track
from the track stack and charts the particle's trajectory. If
secondary particles are generated as a result of an interaction, these
are first converted to a track, and then pushed into the track
stack. In other words, if we consider the entire simulation as a tree,
where the root of the tree represents the particle gun, the nodes
represent the particle-matter interactions, and the leaves represent
interactions which resulted in the particle to either stop, or exit
the closed three-dimensional world, then the tracker is simply
undergoing a {\it depth-first tree traversal}@^depth-first traversal@>.

@** The main program.

@p
@<Include system libraries@>@/
@<Global data structures@>@/
@<Global variables@>@/
@<Global functions@>@/
@<Start application@>@/

@ @<Start application@>=
int main(int argc, char *argv[])
{
	@<Parse command line arguments@>;
	@<Process input files@>;
	@<Create physics tables@>;
	@<Create and process events@>;
	@<Clean up the system@>;
	return 0;
}

@ @<Parse command line arguments@>=

@ @<Process input files@>=

@ @<Create physics tables@>=

@ @<Create and process events@>=
for (i = 0; i < num_events; i++) {
	@<Simulate $i$th event@>;
}

@ @<Clean up the system@>=

@** Vectors.

@<Definition of a three-dimensional vector@>=
struct vect3d_struct {
       double x, y, z;
};
typedef struct vect3d_struct vect3d;

@ @<Calculate vector magnitude@>=
double vect3d_magnitude(vect3d *v)
{
	return sqrt(v->x * v->x +
		    v->y * v->y +
		    v->z * v->z);
}

@ @<Normalise a vector@>=
vect3d vect3d_normalize(vect3d *v)
{
	vect3d t;
	double m = vect3d_magnitude(v);
	if (m > 0.0) {
		t.x = v->x / m;
		t.y = v->y / m;
		t.z = v->z / m;
	} else {
		t.x = 0.0;
		t.y = 0.0;
		t.z = 0.0;
	}
	return t;
}

@** Particle.
A {\it particle}@^particle@> is the lowest-level data structure that
\.{MCS} manipulates. This data structure represents a fundamental
particle in physics, which interacts with the materials in the
world.

Every particle has a {\it position}@^position@>, which is given by a
three-dimensional vector. This position is defined relative to the
origin of the {\it world} coordinate system. Particles also have
{\it mass}@^mass@>, and {\it charge}@^charge@>.

In \.{MCS}, all of the particles to be simulated are generated by the
particle gun, and the origin of these particles are specified by the
vertex used by the particle gun. A particle gun can generate particles
from various vertices. We stored all of the particles generated from a
given vertex as a linked-list. Hence, |next| points to the next
particle in this list; |next = NULL| for the last particle in the
list. Furthermore, during particle-matter interactions, new particles
may be generated. These secondary particles are considered {\it
daughter particles}@^daughter particle@>, and are stored as a
linked-list. The pointer |daughter| points to the head of this linked
list.

@<Definition of a physics particle@>=
struct particle_struct {
        vect3d momentum;
        double mass;  
      	double charge;
      	vect3d polarisation;
	uint32_t num_daughters;
      	struct particle_struct *next;
      	struct particle_struct *daughters;
};
typedef struct particle_struct Particle;

@ Function |create_particle| creates a new particle and returns a
valid particle, or |NULL| if a new particle cannot be created.

@<Create particle@>=
Particle *create_particle(Vertex *v)
{
	Particle *p = (Particle *) malloc(sizeof(Particle));
	if (p) {
	        @<Initialise new particle@>;
		@<Add new particle to the generating vertex@>;
	}
	return p;
}

@ @<Initialise new particle@>=
p->num_daughters = 0;
p->daughters = NULL;

@ @<Add new particle to the generating vertex@>=
p->next = v->particles;
v->particles = p;
v->num_particles++;

@ Function |destroy_particle| destroys a particle and all of its
daughters.

@<Destroy particle@>=
void destroy_particle(Particle *p)
{
	Particle *t;
	if (p == NULL) return;
	while (p->daughters) {
	        t = p->daughters->next;
		destroy_particle(p->daughters);
		p->daughters = t;
	}
	free(p);
}

@ Print a primary including all of its secondary particles.

@<Print particle tree@>=
void print_particle(Particle *p)
{
	Particle *t;
	if (p == NULL) return;
	@<Print particle information@>;
	@<Print daughter particles@>;
}

@ @<Print particle information@>=

@ @<Print daughter particles@>=
t = p->daughters;
while (t) {
	print_particle(t);
	t = t->next;
}

@ @<Generate primary particles@>=
for (k = 0; k < num_particles; k++) {
        current_particle = create_particle(current_vertex);
	if (current_particle == NULL) {
	        fatal("failed to create particle");
		@<Simulation has failed! Exit application@>;
	}
}


@** Vertex.
To generate particles, a particle gun must first be placed inside the
world by choosing a vertex. When the particle gun is activated,
primary particles are generated from this vertex. A vertex is not
associated with a particle gun, however; they are stored with respect
to an event. Hence, an event can have multiple vertices associated
with it. These are stored as a linked-list.

@f uint32_t int
@<Definition of a vertex@>=
struct vertex_struct {
       vect3d position;
       uint32_t num_particles;
       Particle *particles;
       struct vertex_struct *next;
};
typedef struct vertex_struct Vertex;

@ Function |create_vertex| creates a new vertex, and associates the
vertex with the supplied event. This functions returns a pointer to
the vertex, or |NULL| if a new vertex could not be created.

@<Create vertex@>=
Vertex *create_vertex(Event *e)
{
	Vertex *v = (Vertex *) malloc(sizeof(Vertex));
	if (v) {
	        v->particles = NULL;
	        v->num_particles = 0;
	        v->next = e->vertices;
	        e->vertices = v;
	        e->num_vertices++;
	}
	return v;
}

@ Function |destroy_vertex| destroys the vertex by destroying all of
the particles associated with it.

@<Destroy vertex@>=
void destroy_vertex(Vertex *v)
{
	Particle *t;
	if (v == NULL) return;
	while (v->particles) {
	        t = v->particles->next;
		destroy_particle(v->particles);
	        v->particles = t;	
	}
	free(v);
}

@ Print a vertex with all of its primary and secondary particles.

@<Print vertex tree@>=
void print_vertex(Vertex *v)
{
	if (v == NULL) return;
	@<Print vertex information@>;
	@<Print particles@>;
}

@ @<Print vertex information@>=
fprintf(stdout, "\tVertex has %d primary particles\n", v->num_particles);

@ @<Print particles@>=
current_particle = v->particles;
while (current_particle) {
        print_particle(current_particle);
	current_particle = current_particle->next;
}

@ @<Generate vertices@>=
for (j = 0; j < num_vertices; j++) {
        current_vertex = create_vertex(current_event);
	if (current_vertex == NULL) {
	        fatal("failed to create vertex");
		@<Simulation has failed! Exit application@>;
	}
	@<Generate primary particles@>;
}

@** Particle gun.

@<Definition of a particle gun@>=
struct particle_gun_struct {
       uint32_t num_particles; /* no. particles to generate */
       vect3d position; /* vertex position */
       vect3d momentum;
       vect3d polarisation;
       double energy;
       double charge;
};
typedef struct particle_gun_struct Particle_gun;

@ There should be only one particle gun.

@<Reset the particle gun@>=
void reset_particle_gun()
{
        particle_gun.num_particles = 0;
	particle_gun.position = zero_vector;
	particle_gun.momentum = zero_vector;
	particle_gun.polarisation = zero_vector;
	particle_gun.energy = 0.0;
	particle_gun.charge = 0.0;
}

@ All of the particles generated from a vertex will have the same
physical quantities as currently defined by the particle gun 
parameters. Hence, before generating a vertex, the particle gun must
be initialised with the required parameters by invoking the
corresponding |set_pg_*| functions. To generate particles with different
physical quantities, different vertices must be generated after
initialising the particle gun parameters as required.

@ The number of particles to be generated with each activation of the
particle gun.

@<Set num particles to be generated by particle gun@>=
void set_pg_num_particles(uint32_t n)
{
	particle_gun.num_particles = n;
}

@ @<Set position of particle gun@>=
void set_pg_position(vect3d position)
{
	particle_gun.position = position;
}

@ @<Set momentum of particle gun@>=
void set_pg_momentum(vect3d momentum)
{
	particle_gun.momentum = momentum;
}

@ @<Set polarisation of particle gun@>=
void set_pg_polarisation(vect3d polarisation)
{
	particle_gun.polarisation = polarisation;
}

@ @<Set energy of particle gun@>=
void set_pg_energy(double energy)
{
	particle_gun.energy = energy;
}

@ @<Set charge of particle gun@>=
void set_pg_charge(double charge)
{
	particle_gun.charge = charge;
}

@** Events.
An {\it event}@^event@> is the highest-level simulation object. It
provides a link between the user and the simulator. Users specify the
number of events they wish to simulate. An event is associated with
various vertices which specify the locations where a particle gun
could be placed. To generate primary particles, the particle gun must
first be placed on one of the vertices of the event being simulated.

@<Definition of an event@>=
struct event_struct {
       uint32_t id; /* event identifier */
       uint32_t num_vertices;
       Vertex *vertices;
};
typedef struct event_struct Event;

@ @<Create event@>=
Event *create_event(uint32_t id)
{
	Event *e = (Event *) malloc(sizeof(Event));
	if (e) {
	        e->id = id;
		e->num_vertices = 0;
		e->vertices = NULL;
	}
	return e;
}

@ @<Destroy event@>=
void destroy_event(Event *e)
{
	Vertex *v;
	if (e == NULL) return;
	while (e->vertices) {
	      v = e->vertices->next;
	      destroy_vertex(e->vertices);
	      e->vertices = v;
	}
	free(e);
}

@ Print event information, which is a tree with all of the vertices, primary
particles, and secondary daughter particles.

@<Print event tree@>=
void print_event(Event *e)
{
	if (e == NULL) return;
	@<Print event information@>;
	@<Print vertices@>;
}

@ @<Print event information@>=
fprintf(stdout, "Event %2d\n", e->id);
fprintf(stdout, "Number of vertices: %2d\n", e->num_vertices);

@ @<Print vertices@>=
current_vertex = e->vertices;
while (current_vertex) {
        print_vertex(current_vertex);
	current_vertex = current_vertex->next;
}

@ To simulate an event, we first create an event object. Then, we
invoke generate the vertices and the required primary particles.

@<Simulate $i$th event@>=
current_event = create_event(i);
if (current_event == NULL) {
        fatal("failed to create event");
	@<Simulation has failed! Exit application@>;
}
@<Generate vertices@>;
print_event(current_event);
@<Simulate the event@>;
destroy_event(current_event);

@** User specified.

@<Set particle gun parameters@>=

@** Running the simulation.

We use the stack data structure for simulating an event. Before the
simulation begins, all of the primary particles associated with the
event are pushed into the {\it particle stack}@^particle stack@>. Then, we track the particles in the stack until the stack is
empty.

@d MAX_STACK_SIZE 4096
@<Definition of a stack@>=
struct particle_stack_struct {
       uint32_t tos; /* top of stack */
       Particle *particles[MAX_STACK_SIZE];
};
typedef struct particle_stack_struct Particle_stack;

@ @<Clear the particle stack@>=
particle_stack.tos = 0;

@ @<Push particle into particle stack@>=
void push_particle(Particle *p)
{
	if (particle_stack.tos == MAX_STACK_SIZE) return;
	particle_stack.particles[particle_stack.tos++] = p;
}

@ @<Pop particle out of the particle stack@>=
Particle *pop_particle()
{
	if (particle_stack.tos == 0) return NULL;
	return particle_stack.particles[--particle_stack.tos];
}

@ @<Simulate the event@>=
@<Fill in the particle stack for this event@>;
@<Process the particle stack@>;

@ @<Fill in the particle stack for this event@>=
@<Clear the particle stack@>;
current_vertex = current_event->vertices;
while (current_vertex) {
        current_particle = current_vertex->particles;
        while (current_particle) {
	        push_particle(current_particle);
	        current_particle = current_particle->next;
	}
        current_vertex = current_vertex->next;
}

@ @<Process the particle stack@>=
while ((current_particle = pop_particle())) {
      track_particle();
}

@ @<Simulation has failed! Exit application@>=

@** Tracking a particle.

@<Tracking a particle@>=
void track_particle()
{
	info("traking a particle");
}

@** Constructive Solid Geometry.
The tracking happens inside a closed world, and we must define this
world by specifying the solids that are included in this world. We use
{\it Constructive Solid Geometry}@^Constructive Solid Geometry@> to
define solids in the simulation world. Most of the concepts used in this
implementation is based on the books {\it Geometric and Solid
Modelling: An Introduction} by Christoph M. Hoffman [Morgan Kaufmann
Publishers, Inc., (1989)] and {\it An Integrated Introduction to
Computer Graphics and Geometric Modelling} by Ronald Goldman [CRC
Press (2009)].

In constructive solid geometry, complex solids are built from
primitive solids by combining them using well defined
operations. These operations include transformations, such as scaling
and translation, and set-theoretic operations on the volume defined by
two solids. New solids are defined by recursively combining existing
solids using these operations.

@*1 Standard Primitives.
We use four {\it standard primitives}@^standard primitives@> that
define closed solid volumes. These are: the {\it
parallelepiped}@^parallelepiped@>, the {\it sphere}@^sphere@>,
the {\it cylinder}@^cylinder@>, and the {\it torus}@^torus@>. These
primitives are generic and can take different shapes and form. Hence,
to use a given primitive while building a new solid, each primitive
must first be initialised by providing the specific parameters which
define its shape and form.

@<Type definitions@>=
typedef enum {
	BLOCK = 0, SPHERE, CYLINDER, TORUS
} Primitive_type;

@ Forward declaration of data structures that represent data that are
specific to a given primitive type. Their structure will be defined in
the following sections.

@<Type definitions@>=
typedef struct primitive_block_struct Block;
typedef struct primitive_sphere_struct Sphere;
typedef struct primitive_cylinder_struct Cylinder;
typedef struct primitive_torus_struct Torus;

@ The first field of all primitive data stores a primitive type. This
is used while deciding the manner in which a primitive must be
processed: based on this type, we choose the appropriate union
field.

@<Container for a primitive@>=
struct primitive_container_struct {
	Primitive_type type;
	@<Information common to all primitives@>;
	union {
       	        Block b;
       		Sphere s;
       		Cylinder c;
       		Torus t;
	};
};
typedef struct primitive_container_struct Primitive;

@ It is important to note here that, in each of the following sections,
we specify only the relevant details. Additional details will be
incorporated when we discuss other aspects of the solids. For
instance, at the moment we are only concerned with the geometry of the
solids, and not with their material properties. Hence, the
details concerning their material properties will be added later on,
when we discuss materials.

@ Every primitive has a {\it unique identifier}@^unique identifier@>
and a {\it unique name}@^unique name@>. A unique human-readable name
is supplied by the user to each instance of a primitive, as discussed
in |@<Read block geometry from a file@>|. From this name, the
corresponding unique identifier is generated internally for use by
the various algorithms.

@d PRIMITIVE_NAME_MAX_LEN 100
@<Information common to all primitives@>=
uint32_t id; /* unique primitive identifier */
char name[PRIMITIVE_NAME_MAX_LEN];

@ In addition to the {\it global coordinate frame}@^global coordinate frame@>
defined by the simulation world, each initialised primitive also
defines a {\it local coordinate frame}@^local coordinate frame@>.
The origin of this coordinate frame is used by the geometry
construction algorithm to place the primitive inside the simulation
world. Consequently, all translations of a primitive in the simulation
world can be considered as the translation of its origin.

@<Information common to all primitives@>=
vect3d origin;

@*2 Parallelepiped.
For simplicity of exposition, we shall refer to a parallelepiped as
a {\it block}@^block@>. A primitive block stores the following
information.

@<Structure of a primitive block@>=
struct primitive_block_struct {
       @<Information that defines a primitive block@>;
};

@ The geometry of a block is defined by its length, width and
height. The origin of the block's local coordinate frame is defined by
its {\it centroid}@^centroid@>, and the orthogonal axes incident on
this origin, i.e., the $x$, $y$ and $z$ axes of the local coordinate
frame, are aligned respectively in parallel to its length, height and
width.

@<Information that defines a primitive block@>=
double length, height, width;

@ The parameters that are required to initialise a standard primitive
is read from an input file. These parameters must be supplied using
specific formatting requirements. The parameters for the block
geometry are supplied in the following format.

\smallskip

(``name" $x$ $y$ $z$ $length$ $width$ $height$)

\smallskip

For instance, the specification {\tt ("Block A" 100.0 120.0
150.0 10.0 5.0 15.0)} initialises a new block named ``Block A" located
at (100.0, 120.0, 150.0) in the world coordinate frame with length
10.0, width 5.0 and height 15.0. We assume that all of the lengths are
specified using the same unit of measurement. We will discuss in the
following sections how a unit of measurement is selected.

@<Read block geometry from a file@>=
fscanf(f, "(\"%[^\"]\" %lf %lf %lf %lf %lf %lf)\n",
       p->b.name, &p->b.origin.x, &p->b.origin.y, &p->b.origin.z,
       &p->b.length, &p->b.width, &p->b.height);
p->type = BLOCK;

@*2 Sphere.
A primitive sphere stores the following information.

@<Structure of a primitive sphere@>=
struct primitive_sphere_struct {
       @<Information that defines a primitive sphere@>;
};

@ The geometry of a sphere is defined by its radius, and the origin of
its local coordinate frame is defined by the sphere's {\it
center}@^center@>.

@<Information that defines a primitive sphere@>=
double radius;

@ The parameters for the sphere geometry are supplied in the following
format.

\smallskip

(``name" $x$ $y$ $z$ $radius$)

\smallskip

For instance, the specification {\tt ("Sphere A" 100.0 120.0
150.0 10.0)} initialises a new solid sphere named ``Sphere A" located
at (100.0, 120.0, 150.0) in the world coordinate frame with radius
10.0. Again, we assume that the radius is specified in the chosen
unit of measurement, yet to be discussed.

@<Read sphere geometry from a file@>=
fscanf(f, "(\"%[^\"]\" %lf %lf %lf %lf)\n",
       p->s.name, &p->s.origin.x, &p->s.origin.y, &p->s.origin.z,
       &p->s.radius);
p->type = SPHERE;

@*2 Cylinder.
A primitive cylinder stores the following information.

@<Structure of a primitive cylinder@>=
struct primitive_cylinder_struct {
       @<Information that defines a primitive cylinder@>;
};

@ The geometry of a cylinder is defined by its base radius and its
height.  The origin of the block's local coordinate frame is defined by
its {\it centroid}@^centroid@>, and the orthogonal axes incident on
this origin, i.e., the $x$, $y$ and $z$ axes of the local coordinate
frame, are aligned so that $y$ axis is perpendicular to the base.

@<Information that defines a primitive cylinder@>=
double radius, height;

@ The parameters for the cylinder geometry are supplied in the following
format.

\smallskip

(``name" $x$ $y$ $z$ $radius$ $height$)

\smallskip

For instance, the specification {\tt ("Cylinder A" 100.0 120.0
150.0 10.0 20.0)} initialises a new solid cylinder named ``Cylinder A"
located at (100.0, 120.0, 150.0) in the world coordinate frame with
base radius 10.0 and height 20.0.

@<Read cylinder geometry from a file@>=
fscanf(f, "(\"%[^\"]\" %lf %lf %lf %lf)\n",
       p->c.name, &p->c.origin.x, &p->c.origin.y, &p->c.origin.z,
       &p->c.radius, &p->c.height);
p->type = CYLINDER;

@*2 Torus.
A primitive torus stores the following information.

@<Structure of a primitive torus@>=
struct primitive_torus_struct {
       @<Information that defines a primitive torus@>;
};

@ The geometry of a primitive torus can be defined parametrically as
follows:

\halign{\hfil $#$ & $#$ & $#$ \hfil \cr
    x(u, v) & = & (R + r \cos{v}) \cos{u} \cr
    y(u, v) & = & (R + r \cos{v}) \sin{u} \cr
    z(u, v) & = & r \sin{v} \cr}

\noindent where, parameters $u$ and $v$ specify angles in radians such
that $0 \le u, v < 2\pi$. The length $R$ gives the distance from the
center of the tube to the center of the torus, and the length $r$
gives the radius of the tube. The parameters $R$ and $r$ are also
referred to as the {\it major radius}@^major radius@> and the {\it
minor radius}@^minor radius@>, respecticely; and their ratio is
referred to as the {\it aspect ratio}@^aspect ratio@>.

The origin of the torus' local coordinate frame is defined by
its {\it center}@^center@>, and the orthogonal axes incident on
this origin are aligned so that its $y$ axis is perpendicular to the
radial surface emanating from the origin to the center of the tube.

@<Information that defines a primitive torus@>=
double major, minor;
double u, v;

@ The parameters for the torus geometry are supplied in the following
format.

\smallskip

(``name" $x$ $y$ $z$ $u$ $v$ $major$ $minor$)

\smallskip

For instance, the specification {\tt ("Torus A" 100.0 120.0
150.0 0.0 359.999999 10.0 2.0)} initialises a solid torus named
``Torus A" located at (100.0, 120.0, 150.0) in the world coordinate
frame with major radius 10.0 and minor 2.0. Note here that $v < 2\pi$.

@<Read torus geometry from a file@>=
fscanf(f, "(\"%[^\"]\" %lf %lf %lf %lf %lf %lf %lf)\n",
       p->t.name, &p->t.origin.x, &p->t.origin.y, &p->t.origin.z,
       &p->t.u, &p->t.v, &p->t.major, &p->t.minor);
p->type = TORUS;

@*1 Constructive Solid Geometry Tree.
All solids are built from primitive solids by using regularised
set-theoretic operators. These operators work on the volume defined by
the primitive solids. There are three regularised set-theoretic
operators: {\it union}@^union@>, {\it intersection}@^intersection@>
and {\it difference}@^difference@>, which respectively
defines the volume union, intersection and difference of two solid
primitives.

Further to these operators, transformation and translation
operators are defined, which changes the shape, form, orientation and
location of the solid primitives relative to the world coordinate
frame. These are unary operators, as compared to the binary
set-theoretic operators.

@<Type definitions@>=
typedef enum {
	UNION = 1, INTERSECTION, DIFFERENCE,
	TRANSLATE, SCALE, ROTATE
} CSG_Operator;

@ To build a solid, the required operators must be applied to several
solid primitives in a specific order. This order is expressed
using a binary tree, referred to as the {\it Constructive
Solid Geometry Tree}@^Constructive Solid Geometry Tree@>, or {\it
CSG Tree}@^CSG Tree@> for short. This structure stores a pointer to
the root node, and maintains several house-keeping data.

@<Structure of a constructive solid geometry tree@>=
typedef struct csg_node_struct CSG_Node;
struct csg_tree_struct {
       @<House-keeping data@>;
       CSG_Node *root; /* pointer to the CSG root */
};
typedef struct csg_tree_struct CSG_Tree;

@ We only maintain the overall statistics for the entire CSG tree. If
we wish to obtain statistical information for a given sub-solid, and
there are multiple solids in the CSG tree, then this information
must be derived at runtime by traversing the sub-tree which
corresponds to the selected solid. We only store the overall
statistics to minimise the memory footprint for storing each tree
node.

@f uint16_t int
@<House-keeping data@>=
uint16_t num_primitive;
uint16_t num_union;
uint16_t num_intersect;
uint16_t num_difference;
uint16_t num_translate;
uint16_t num_rotate;
uint16_t num_scale;

@ The internal nodes of a CSG tree store operators. If the operator
stored is binary (i.e., the set-theoretic operators) both left and
right children point to solids. If the operator is unary, the left
child points to a solid, and the right child stores the operator
parameters (e.g., the displacement if we are translating a solid, or
the scaling factor if we are scaling a solid, etc.).

@<Structure of a CSG internal node@>=
struct csg_internal_node_struct {
       CSG_Node *left, *right; /* pointers to the left and right subtrees */
};
typedef struct csg_internal_node_struct CSG_Internal;

@ CSG leaf nodes that store solids or unary operator parameters,
require additional data. For a node with an unary operator, this
consists of operator parameters; and for solid nodes, a pointer to the
solid.

@<Structure of the data stored in a leaf node@>=
union csg_leaf_union {
       struct translation_parameters t;
       struct rotation_parameters r;
       struct scaling_parameters s;
       Primitive *p;
};
typedef union csg_leaf_union CSG_Leaf;

@ To differentiate between node types, each node stores a
|CSG_Operator| field. This field is set to zero if the node is a leaf
(i.e., the node either stores a solid, or stores the parameter of a
unary operator); otherwise, the node is an internal node and stores an
operator.

@<Structure of a CSG tree node@>=
struct csg_node_struct {
       CSG_Operator op; /* operator if value $> 0$; parameter or leaf, otherwise */
       union {
               CSG_Leaf leaf;
	       CSG_Internal internal;
       };
};


@*2 Union.

The union of two solids is defined as the volume which consist of
points that are both 

, intersection and difference of two solids are specified in the
geometry input file using the following format.

\smallskip

(``result" ``left solid" ``right solid")

\smallskip

\noindent where, ``left solid" and ``right solid" are the names of the
operands, and the result of the operation is stored using the name
``result". Both operands could be primitive solids, or intermediate
solids that is defined by a CSG sub-tree. The order of the operands
are important when applying the difference operator.

For instance, the specification {\tt ("D1" "Cylinder A" "Torus A")}
for the difference of two solids means, stores in "D1" the difference
of subtracting the volume defined by "Torus A" from the volume defined
by solid "Cylinder A".

@<Read binary operation from a file@>=
fscanf(f, "(\"%[^\"]\" \"%[^\"]\" \"%[^\"]\")\n",
&op_result, &op_left, &op_right);


@*2 Translation.

Translation relocates a solid by displacing its origin in the $x$, $y$
and $z$ axes. Hence, the paramaters for a translation operator is
specified as a |displacement| vector. The unit of displacement depends
on the unit chosen by the user when specifying the CSG tree.

@<Structure for translation parameters@>=
struct translation_parameters {
       vect3d displacement; /* displacement of solid origin */
};

@ @<Read translation operation from a file@>=
@<Read translation parameters@>;
@<Find the target solid for the translation@>;
@<Create translation parameter node@>; 
@<Create translation operator node@>;

@ The translation parameters are specified in the geometry input file
using the following format.

\smallskip

(``solid" dx dy dz)

\smallskip

\noindent where, ``solid" is the name of the target solid which we
wish to translate, and $dx$, $dy$ and $dz$ are the respective
displacements along the $x$, $y$ and $z$ axes. For instance, the
translation specification {\tt ("D1" 10.0 50.0 20.0)} means, translate
the solid associated with the name ``D1" by displacing its origin by
10.0 units along the $x$ axis, 50.0 units along the $y$ axis, and 20.0
units along the $z$ axis.

@<Read translation parameters@>=
fscanf(f, "(\"%[^\"]\" %lf %lf %lf)\n", &op_target, &op_x, &op_y, &op_z);
input_file_current_line++;

@ In order for a translation to be applicable, the supplied target
solid must already exists within the system, either by prior
definition as a primitive solid, or as an intermediate solid
defined by a CSG subtree.

@<Find the target solid for the translation@>=
if ((target_solid = find_solid(op_target)) == NULL) {
        fprintf(stderr, "%s[%d] Invalid geometry specification...\n"@/
	"Could not find solid named '%s'\n", input_file_name,
	input_file_current_line, op_target);
	goto error_invalid_file;
}

@ We now have a valid translation, so create the parameter leaf
node which will become the right-child of the translation operator node.

@<Create translation parameter node@>=
if ((parameter_node = create_csg_node()) != NULL) {
        parameter_node->op = 0; /* this is a leaf node */
	parameter_node->leaf.t.displacement.x = op_x;
	parameter_node->leaf.t.displacement.y = op_y;
	parameter_node->leaf.t.displacement.z = op_z;
}

@ Finally, create the translation operator node, and attach the target
solid and the parameter node.

@<Create translation operator node@>=
if ((operator_node = create_csg_node()) != NULL) {
        operator_node->op = TRANSLATE; /* this is an internal node */
	operator_node->internal->left = target_solid;
	operator_node->internal->right = parameter_node;
}

@*2 Rotation.

We rotate a solid relative to an axis. The angle of rotation
$\theta$ is specified in {\it radians}@^radians@>. If $\theta < 0$, we
have {\it clockwise rotation}@^clockwise rotation@>; if $\theta > 0$,
we have {\it anticlockwise rotation}@^anticlockwise rotation@>.
When $\theta = 0$, no rotation is applied. In order to
apply a rotation, we also need an {\it axis of rotation}@^axis of rotation@>.
This is specified as a unit vector@^unit vector@> named |axis|.

@<Structure for rotation parameters@>=
struct rotation_parameters {
       double theta; /* angle of rotation in radians */
       vect3d axis; /* axis of rotation (unit vector) */
};

@*2 Scaling.

Scaling increases or decreases the volume of a solid. The amount of
scaling applied with respect to each of the axes are specified using a
|scale| vector. If the scaling factors are all zero, scaling is not
applied. A scaling transformation maintains the shape and the form of
the solid if and only if the scaling factor along all of the axes are
equal.

@<Structure for scaling parameters@>=
struct scaling_parameters {
       vect3d scale; /* scaling factor */
};


@*1 The geometry input file.
The geometry of the solids and their placement and orientation within
the world is specified in the input file. The grammar for this input
file is very simple. The file consist of several commands, where an
entire line of text is used to specify a specific command. Each
command has the following format:

\smallskip

$\langle command \rangle \langle parameters \rangle \langle newline \rangle$

\smallskip

Here, $\langle command \rangle$ is a single character code, which
defines its intended action. The commands and their intended actions
are as follows: 

\smallskip

$$\vcenter{\halign{\hfil {\tt #} & # \hfil \cr
B, S, C, T & Create a primitive block, sphere, cylinder, or torus.\cr
u, i, d & Carry out a union, intersection, or difference.\cr
t, r, s & Translate, rotate, or scale the solid.\cr
}}$$

\smallskip

To support this intended action, the user must supply all of the
required parameters in the $\langle parameters \rangle$
field. Finally, every command must be terminated by a $\langle newline
\rangle$ character. The following is an example:

\bigskip

{\tt
T ("Torus A" 100.0 120.0 150.0 0.0 359.999999 10.0 2.0)

C ("Cylinder A" 110.0 120.0 150.0 10.0 20.0)

C ("Cylinder B" 120.0 120.0 150.0 10.0 20.0)

u ("U1" "Torus A" "Cylinder A")

d ("D1" "U1" "Cylinder B")

t ("D1" 10.0 50.0 20.0)

s ("D1" 10.0 20.0 30.0)
}

\bigskip

We have already discussed how the $\langle parameters \rangle$ field
is specified in the respective sections.

@ @<Read geometry from input file@>=
CSG_Tree *read_geometry(FILE *f)
{
	CSG_Tree *t;
	char c;
	while ((c = fgetc(f)) != EOF) {
	        @<Process input command@>;
	}
	return t;

error_invalid_file:
	@<Cleanup resources allocated to invalid geometry@>;
	return NULL;
}

@ @<Cleanup resources allocated to invalid geometry@>=

@ @<Process input command@>=
switch(c) {
case 'b':
	@<Read block geometry from a file@>;
     	break;
case 's':
	@<Read sphere geometry from a file@>;
     	break;
case 'c':
	@<Read cylinder geometry from a file@>;
        break;
case 't':
        @<Read torus geometry from a file@>;
        break;
default:
        goto error_invalid_file;
}



@** Error handling.
There are three message categories, which are printed using the
following macros: |fatal|, |warn|, and |info|.

@d fatal(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d warn(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d info(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);

@ @<Include system libraries@>=
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

@ @<Global variables@>=
uint32_t i, j, k, l, m, n; /* counters */
Event *current_event = NULL;
Vertex *current_vertex = NULL;
Particle *current_particle = NULL;
uint32_t num_events = 5;
uint32_t num_vertices = 5;
uint32_t num_particles = 5;
Particle_gun particle_gun;
Particle_stack particle_stack;
vect3d zero_vector = { 0.0, 0.0, 0.0 };

@ @<Global data structures@>=
@<Type definitions@>;
@<Definition of a three-dimensional vector@>;
@<Definition of a physics particle@>;
@<Definition of a vertex@>;
@<Definition of an event@>;
@<Definition of a particle gun@>;
@<Definition of a stack@>;
@<Structure of a primitive block@>;
@<Structure of a primitive sphere@>;
@<Structure of a primitive cylinder@>;
@<Structure of a primitive torus@>;
@<Container for a primitive@>;
@<Structure of a constructive solid geometry tree@>;
@<Structure of a CSG internal node@>;
@<Structure for translation parameters@>;
@<Structure for rotation parameters@>;
@<Structure for scaling parameters@>;
@<Structure of the data stored in a leaf node@>;
@<Structure of a CSG tree node@>;


@ @<Global functions@>=
@<Calculate vector magnitude@>;
@<Normalise a vector@>;
@<Create particle@>;
@<Create vertex@>;
@<Create event@>;
@<Destroy particle@>;
@<Destroy vertex@>;
@<Destroy event@>;
@<Reset the particle gun@>;
@<Set num particles to be generated by particle gun@>;
@<Set position of particle gun@>;
@<Set momentum of particle gun@>;
@<Set polarisation of particle gun@>;
@<Set energy of particle gun@>;
@<Set charge of particle gun@>;
@<Print particle tree@>;
@<Print vertex tree@>;
@<Print event tree@>;
@<Push particle into particle stack@>;
@<Pop particle out of the particle stack@>;
@<Tracking a particle@>;
@<Set particle gun parameters@>;
@<Read block geometry from a file@>;
@<Read geometry from input file@>;

@* History.
The {\it Monte Carlo Simulator} project began in June 2011, when
Dr.~Gagarine Yaikhom was a WIMCS Research Fellow under Prof.~David
W. Walker at Cardiff University. The initial aim of the project was to
port the Geant4 system to run on CUDA GPUs. However, after studying
the Geant4 code-base, we concluded that it will be prohibitive to port
the entire Geant4 system given the short duration of the funding (8
months, from June 2011 until January 2012) and that only Dr.~Yaikhom
will be carrying out the design and implementation. We, therefore,
decided to use the Geant4 system only as a guideline system
architecture, and to reimplement the performance-intensive concepts
and their dependencies for a simplified simulator. This
implementation, which began on 5 August 2011, uses data structures
and algorithms that are more appropriate for eventual multithreaded
parallelisation on GPUs.

@**Index.

