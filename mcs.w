@** Introduction.
The {\it Monte Carlo Simulator}, \.{MCS} in short, is a simulation
package for high-energy physics. It uses Monte Carlo techniques for
the randomised simulation of particle interactions. The system borrows
concepts defined in the Geant4 system; however, they have been
reimplemented using ANSI \CEE/ using new data structures and
algorithms with the aim that the system will be ported eventually to GPGPUs.

The \.{MCS} system is in effect an event processor. The user specifies
the number of events they wish to simulate, and provides the system
with the necessary details to process each of the events. These
details include procedures and data for generating the particles for
each event, and the {\it physics processes}@^physics processes@>
required by the type of the particle being simulated and the
properties of the materials involved in each of the interactions. We
are only interested in interactions that are happening inside a closed
three-dimensional system, referred to as the {\it
world}@^world@>. Since the world is defined by the components present,
the user must provide the geometry of the components in addition to
the properties of the materials the components are made of. In this
document, these input data will be referred to {\it simulation
parameters}@^simulation parameters@>.

Once the \.{MCS} system is supplied with a valid set of simulation
parameters, it processes the geometries and creates a data structure
that allows efficient location of an interaction point. This is an
important step because, to process a large number of interactions
rapidly, we must efficiently find the location inside the world where
the interactions are happening, as it determines the materials
required by the processes.

We then define the {\it particle gun}@^particle gun@>, which generates
the required number of {\it primary particles}@^primary particles@>
for each of the events. Primary particles are particles that are
generated explicitly by a particle gun, and {\it secondary
particles}@^secondary particles@> are those that are generated as a
result of particle-matter interaction. Since multiple primary
particles may be generated by an event, a {\it vertex}@^vertex@> is
defined for each event. For any given event the associated vertex
provides the location of the particle gun, so that all of the
particles generated originates from this location. When the particle
gun is activated, a set of primary particles are generated. These
particles have the same origin, as defined by the vertex location,
however, they carry different properties, such as energy, momentum,
etc. These values are set using a {\it random number
generator}@^random number generator@>.

Once a particle has been generated, it travels through the materials
until it either comes to a stop, or exits the closed three-dimensional
world. Throughout this journey, the {\it trajectory}@^trajectory@> of
the particle changes depending on its interaction with the
materials. Hence, the \.{MCS} system uses a {\it tracker}@^tracker@>
to track each of the particles throughout its journey.
A snapshot of the particle in its trajectory is referred to as a
{\it track}@^track@>, and is processed independently of any previous
tracks. In other words, a track does not remember its past. Hence, to
keep a record of the trajectory, the tracker records old tracks as new
ones are derived. Each of these points on the trajectory is referred
to as the {\it step point}@^step point@>, and the process of moving to
the next step point as {\it stepping}@^stepping@>. Hence, we invoke
multiple stepping commands to chart the entire trajectory of a
particle.

To move a particle from one track to the next, each stepping decides
the length with which the particle must progress. This is referred to
as a {\it step}@^step@>. Each step has a start point and an end
point. These points store information for retrieving the material
properties that are required by each of the physics processes that are
valid in that stepping. The length of a step is determined by the
process which requires the shortest space-time {\it interaction
length}@^interaction length@>. In other words, the next track must be
located in space-time so that all of the valid physics processes are
applicable.

We use a {\it stack}@^stack@> to store all of the unprocessed
particles, both primary and secondary. At the beginning of each event,
each of the primary particles generated by the particle gun are first
converted to a track, so that the tracker can process them. Then, the
tracks are all pushed into the {\it track stack}@^track stack@>. This
stack is then passed to the tracker, which continuously pops a track
from the track stack and charts the particle's trajectory. If
secondary particles are generated as a result of an interaction, these
are first converted to a track, and then pushed into the track
stack. In other words, if we consider the entire simulation as a tree,
where the root of the tree represents the particle gun, the nodes
represent the particle-matter interactions, and the leaves represent
interactions which resulted in the particle to either stop, or exit
the closed three-dimensional world, then the tracker is simply
undergoing a {\it depth-first tree traversal}@^depth-first traversal@>.

@** The main program.

@p
@<Include system libraries@>@/
@<Global data structures@>@/
@<Global variables@>@/
@<Global functions@>@/
@<Start application@>@/

@ @<Start application@>=
int main(int argc, char *argv[])
{
	@<Parse command line arguments@>;
	@<Process input files@>;
	@<Create physics tables@>;
	@<Create and process events@>;
	@<Clean up the system@>;
	return 0;
}

@ @<Parse command line arguments@>=

@ @<Process input files@>=

@ @<Create physics tables@>=

@ @<Create and process events@>=
for (i = 0; i < num_events; i++) {
	@<Simulate $i$th event@>;
}

@ @<Clean up the system@>=

@** Vectors.

@<Definition of a three-dimensional vector@>=
struct vect3d_struct {
       double x, y, z;
};
typedef struct vect3d_struct vect3d;

@ @<Calculate vector magnitude@>=
double vect3d_magnitude(vect3d *v)
{
	return sqrt(v->x * v->x +
		    v->y * v->y +
		    v->z * v->z);
}

@ @<Normalise a vector@>=
vect3d vect3d_normalize(vect3d *v)
{
	vect3d t;
	double m = vect3d_magnitude(v);
	if (m > 0.0) {
		t.x = v->x / m;
		t.y = v->y / m;
		t.z = v->z / m;
	} else {
		t.x = 0.0;
		t.y = 0.0;
		t.z = 0.0;
	}
	return t;
}

@** Particle.
A {\it particle}@^particle@> is the lowest-level data structure that
\.{MCS} manipulates. This data structure represents a fundamental
particle in physics, which interacts with the materials in the
world.

Every particle has a {\it position}@^position@>, which is given by a
three-dimensional vector. This position is defined relative to the
origin of the {\it world} coordinate system. Particles also have
{\it mass}@^mass@>, and {\it charge}@^charge@>.

In \.{MCS}, all of the particles to be simulated are generated by the
particle gun, and the origin of these particles are specified by the
vertex used by the particle gun. A particle gun can generate particles
from various vertices. We stored all of the particles generated from a
given vertex as a linked-list. Hence, |next| points to the next
particle in this list; |next = NULL| for the last particle in the
list. Furthermore, during particle-matter interactions, new particles
may be generated. These secondary particles are considered {\it
daughter particles}@^daughter particle@>, and are stored as a
linked-list. The pointer |daughter| points to the head of this linked
list.

@<Definition of a physics particle@>=
struct particle_struct {
        vect3d momentum;
        double mass;  
      	double charge;
      	vect3d polarisation;
	uint32_t num_daughters;
      	struct particle_struct *next;
      	struct particle_struct *daughters;
};
typedef struct particle_struct Particle;

@ Function |create_particle| creates a new particle and returns a
valid particle, or |NULL| if a new particle cannot be created.

@<Create particle@>=
Particle *create_particle(Vertex *v)
{
	Particle *p = (Particle *) malloc(sizeof(Particle));
	if (p) {
	        @<Initialise new particle@>;
		@<Add new particle to the generating vertex@>;
	}
	return p;
}

@ @<Initialise new particle@>=
p->num_daughters = 0;
p->daughters = NULL;

@ @<Add new particle to the generating vertex@>=
p->next = v->particles;
v->particles = p;
v->num_particles++;

@ Function |destroy_particle| destroys a particle and all of its
daughters.

@<Destroy particle@>=
void destroy_particle(Particle *p)
{
	Particle *t;
	if (p == NULL) return;
	while (p->daughters) {
	        t = p->daughters->next;
		destroy_particle(p->daughters);
		p->daughters = t;
	}
	free(p);
}

@ Print a primary including all of its secondary particles.

@<Print particle tree@>=
void print_particle(Particle *p)
{
	Particle *t;
	if (p == NULL) return;
	@<Print particle information@>;
	@<Print daughter particles@>;
}

@ @<Print particle information@>=

@ @<Print daughter particles@>=
t = p->daughters;
while (t) {
	print_particle(t);
	t = t->next;
}

@ @<Generate primary particles@>=
for (k = 0; k < num_particles; k++) {
        current_particle = create_particle(current_vertex);
	if (current_particle == NULL) {
	        fatal("failed to create particle");
		@<Simulation has failed! Exit application@>;
	}
}


@** Vertex.
To generate particles, a particle gun must first be placed inside the
world by choosing a vertex. When the particle gun is activated,
primary particles are generated from this vertex. A vertex is not
associated with a particle gun, however; they are stored with respect
to an event. Hence, an event can have multiple vertices associated
with it. These are stored as a linked-list.

@f uint32_t int
@<Definition of a vertex@>=
struct vertex_struct {
       vect3d position;
       uint32_t num_particles;
       Particle *particles;
       struct vertex_struct *next;
};
typedef struct vertex_struct Vertex;

@ Function |create_vertex| creates a new vertex, and associates the
vertex with the supplied event. This functions returns a pointer to
the vertex, or |NULL| if a new vertex could not be created.

@<Create vertex@>=
Vertex *create_vertex(Event *e)
{
	Vertex *v = (Vertex *) malloc(sizeof(Vertex));
	if (v) {
	        v->particles = NULL;
	        v->num_particles = 0;
	        v->next = e->vertices;
	        e->vertices = v;
	        e->num_vertices++;
	}
	return v;
}

@ Function |destroy_vertex| destroys the vertex by destroying all of
the particles associated with it.

@<Destroy vertex@>=
void destroy_vertex(Vertex *v)
{
	Particle *t;
	if (v == NULL) return;
	while (v->particles) {
	        t = v->particles->next;
		destroy_particle(v->particles);
	        v->particles = t;	
	}
	free(v);
}

@ Print a vertex with all of its primary and secondary particles.

@<Print vertex tree@>=
void print_vertex(Vertex *v)
{
	if (v == NULL) return;
	@<Print vertex information@>;
	@<Print particles@>;
}

@ @<Print vertex information@>=
fprintf(stdout, "\tVertex has %d primary particles\n", v->num_particles);

@ @<Print particles@>=
current_particle = v->particles;
while (current_particle) {
        print_particle(current_particle);
	current_particle = current_particle->next;
}

@ @<Generate vertices@>=
for (j = 0; j < num_vertices; j++) {
        current_vertex = create_vertex(current_event);
	if (current_vertex == NULL) {
	        fatal("failed to create vertex");
		@<Simulation has failed! Exit application@>;
	}
	@<Generate primary particles@>;
}

@** Particle gun.

@<Definition of a particle gun@>=
struct particle_gun_struct {
       uint32_t num_particles; /* no. particles to generate */
       vect3d position; /* vertex position */
       vect3d momentum;
       vect3d polarisation;
       double energy;
       double charge;
};
typedef struct particle_gun_struct Particle_gun;

@ There should be only one particle gun.

@<Reset the particle gun@>=
void reset_particle_gun()
{
        particle_gun.num_particles = 0;
	particle_gun.position = zero_vector;
	particle_gun.momentum = zero_vector;
	particle_gun.polarisation = zero_vector;
	particle_gun.energy = 0.0;
	particle_gun.charge = 0.0;
}

@ All of the particles generated from a vertex will have the same
physical quantities as currently defined by the particle gun 
parameters. Hence, before generating a vertex, the particle gun must
be initialised with the required parameters by invoking the
corresponding |set_pg_*| functions. To generate particles with different
physical quantities, different vertices must be generated after
initialising the particle gun parameters as required.

@ The number of particles to be generated with each activation of the
particle gun.

@<Set num particles to be generated by particle gun@>=
void set_pg_num_particles(uint32_t n)
{
	particle_gun.num_particles = n;
}

@ @<Set position of particle gun@>=
void set_pg_position(vect3d position)
{
	particle_gun.position = position;
}

@ @<Set momentum of particle gun@>=
void set_pg_momentum(vect3d momentum)
{
	particle_gun.momentum = momentum;
}

@ @<Set polarisation of particle gun@>=
void set_pg_polarisation(vect3d polarisation)
{
	particle_gun.polarisation = polarisation;
}

@ @<Set energy of particle gun@>=
void set_pg_energy(double energy)
{
	particle_gun.energy = energy;
}

@ @<Set charge of particle gun@>=
void set_pg_charge(double charge)
{
	particle_gun.charge = charge;
}

@** Events.
An {\it event}@^event@> is the highest-level simulation object. It
provides a link between the user and the simulator. Users specify the
number of events they wish to simulate. An event is associated with
various vertices which specify the locations where a particle gun
could be placed. To generate primary particles, the particle gun must
first be placed on one of the vertices of the event being simulated.

@<Definition of an event@>=
struct event_struct {
       uint32_t id; /* event identifier */
       uint32_t num_vertices;
       Vertex *vertices;
};
typedef struct event_struct Event;

@ @<Create event@>=
Event *create_event(uint32_t id)
{
	Event *e = (Event *) malloc(sizeof(Event));
	if (e) {
	        e->id = id;
		e->num_vertices = 0;
		e->vertices = NULL;
	}
	return e;
}

@ @<Destroy event@>=
void destroy_event(Event *e)
{
	Vertex *v;
	if (e == NULL) return;
	while (e->vertices) {
	      v = e->vertices->next;
	      destroy_vertex(e->vertices);
	      e->vertices = v;
	}
	free(e);
}

@ Print event information, which is a tree with all of the vertices, primary
particles, and secondary daughter particles.

@<Print event tree@>=
void print_event(Event *e)
{
	if (e == NULL) return;
	@<Print event information@>;
	@<Print vertices@>;
}

@ @<Print event information@>=
fprintf(stdout, "Event %2d\n", e->id);
fprintf(stdout, "Number of vertices: %2d\n", e->num_vertices);

@ @<Print vertices@>=
current_vertex = e->vertices;
while (current_vertex) {
        print_vertex(current_vertex);
	current_vertex = current_vertex->next;
}

@ To simulate an event, we first create an event object. Then, we
invoke generate the vertices and the required primary particles.

@<Simulate $i$th event@>=
current_event = create_event(i);
if (current_event == NULL) {
        fatal("failed to create event");
	@<Simulation has failed! Exit application@>;
}
@<Generate vertices@>;
print_event(current_event);
@<Simulate the event@>;
destroy_event(current_event);

@** User specified.

@<Set particle gun parameters@>=

@** Running the simulation.

We use the stack data structure for simulating an event. Before the
simulation begins, all of the primary particles associated with the
event are pushed into the {\it particle stack}@^particle stack@>. Then, we track the particles in the stack until the stack is
empty.

@d MAX_STACK_SIZE 4096
@<Definition of a stack@>=
struct particle_stack_struct {
       uint32_t tos; /* top of stack */
       Particle *particles[MAX_STACK_SIZE];
};
typedef struct particle_stack_struct Particle_stack;

@ @<Clear the particle stack@>=
particle_stack.tos = 0;

@ @<Push particle into particle stack@>=
void push_particle(Particle *p)
{
	if (particle_stack.tos == MAX_STACK_SIZE) return;
	particle_stack.particles[particle_stack.tos++] = p;
}

@ @<Pop particle out of the particle stack@>=
Particle *pop_particle()
{
	if (particle_stack.tos == 0) return NULL;
	return particle_stack.particles[--particle_stack.tos];
}

@ @<Simulate the event@>=
@<Fill in the particle stack for this event@>;
@<Process the particle stack@>;

@ @<Fill in the particle stack for this event@>=
@<Clear the particle stack@>;
current_vertex = current_event->vertices;
while (current_vertex) {
        current_particle = current_vertex->particles;
        while (current_particle) {
	        push_particle(current_particle);
	        current_particle = current_particle->next;
	}
        current_vertex = current_vertex->next;
}

@ @<Process the particle stack@>=
while ((current_particle = pop_particle())) {
      track_particle();
}

@ @<Simulation has failed! Exit application@>=

@** Tracking a particle.

@<Tracking a particle@>=
void track_particle()
{
	info("traking a particle");
}

@** Constructive Solid Geometry.
The tracking happens inside a closed world, and we must define this
world by specifying the solids that are included in this world. We use
{\it Constructive Solid Geometry}@^Constructive Solid Geometry@> to
define solids in the simulation world. Most of the concepts used in this
implementation is based on the books {\it Geometric and Solid
Modelling: An Introduction} by Christoph M. Hoffman [Morgan Kaufmann
Publishers, Inc., (1989)] and {\it An Integrated Introduction to
Computer Graphics and Geometric Modelling} by Ronald Goldman [CRC
Press (2009)].

In constructive solid geometry, complex solids are built from
primitive solids by combining them using well defined
operations. These operations include transformations, such as scaling
and translation, and set-theoretic operations on the volume defined by
two solids. New solids are defined by recursively combining existing
solids using these operations.

@*1 Standard Primitives.
We use four {\it standard primitives}@^standard primitives@> that
define closed solid volumes. These are: the {\it
parallelepiped}@^parallelepiped@>, the {\it sphere}@^sphere@>,
the {\it cylinder}@^cylinder@>, and the {\it torus}@^torus@>. These
primitives are generic and can take different shapes and form. Hence,
to use a given primitive while building a new solid, each primitive
must first be initialised by providing the specific parameters which
define its shape and form.

It is important to note here that, in each of the following sections,
we specify only the relevant details. Additional details will be
incorporated when we discuss other aspects of the solids. For
instance, at the moment we are only concerned with the geometry of the
solids, and not with their material properties. Hence, the
details concerning their material properties will be added later on,
when we discuss materials.

@ Every primitive has a {\it unique identifier}@^unique identifier@>
and a {\it unique name}@^unique name@>. A unique human-readable name
is supplied by the user to each instance of a primitive, as discussed
in |@<Read block geometry from a file@>|. From this name, the
corresponding unique identifier is generated internally for use by
the various algorithms.

@d PRIMITIVE_NAME_MAX_LEN 100
@<Information common to all primitives@>=
uint32_t id; /* unique primitive identifier */
char name[PRIMITIVE_NAME_MAX_LEN];

@ In addition to the {\it global coordinate frame}@^global coordinate frame@>
defined by the simulation world, each initialised primitive also
defines a {\it local coordinate frame}@^local coordinate frame@>.
The origin of this coordinate frame is used by the geometry
construction algorithm to place the primitive inside the simulation
world. Consequently, all translations of a primitive in the simulation
world can be considered as the translation of its origin.

@<Information common to all primitives@>=
vect3d origin;

@*2 Parallelepiped.
For simplicity of exposition, we shall refer to a parallelepiped as
a {\it block}@^block@>. A primitive block stores the following
information.

@<Structure of a primitive block@>=
struct primitive_block_struct {
       @<Information common to all primitives@>;
       @<Information that defines a primitive block@>;
};
typedef struct primitive_block_struct Block;

@ The geometry of a block is defined by its length, width and
height. The origin of the block's local coordinate frame is defined by
its {\it centroid}@^centroid@>, and the orthogonal axes incident on
this origin, i.e., the $x$, $y$ and $z$ axes of the local coordinate
frame, are aligned respectively in parallel to its length, height and
width.

@<Information that defines a primitive block@>=
double length, height, width;

@ The parameters that are required to initialise a standard primitive
is read from an input file. These parameters must be supplied using
specific formatting requirements. The parameters for the block
geometry are supplied in the following format.

\smallskip

({\bf block} ``name" $x$ $y$ $z$ $length$ $width$ $height$)

\smallskip

For instance, the specification {\tt (block "Block A" 100.0 120.0
150.0 10.0 5.0 15.0)} initialises a new block named ``Block A" located
at (100.0, 120.0, 150.0) in the world coordinate frame with length
10.0, width 5.0 and height 15.0. We assume that all of the lengths are
specified using the same unit of measurement. We will discuss in the
following sections how a unit of measurement is selected.

@<Read block geometry from a file@>=
fscanf(f, "(block \"%[^\"]\" %lf %lf %lf %lf %lf %lf)\n",
       p->name, &p->origin.x, &p->origin.y, &p->origin.z,
       &p->length, &p->width, &p->height);

@*2 Sphere.
A primitive sphere stores the following information.

@<Structure of a primitive sphere@>=
struct primitive_sphere_struct {
       @<Information common to all primitives@>;
       @<Information that defines a primitive sphere@>;
};
typedef struct primitive_sphere_struct Sphere;

@ The geometry of a sphere is defined by its radius, and the origin of
its local coordinate frame is defined by the sphere's {\it
center}@^center@>.

@<Information that defines a primitive sphere@>=
double radius;

@ The parameters for the sphere geometry are supplied in the following
format.

\smallskip

({\bf sphere} ``name" $x$ $y$ $z$ $radius$)

\smallskip

For instance, the specification {\tt (sphere "Sphere A" 100.0 120.0
150.0 10.0)} initialises a new solid sphere named ``Sphere A" located
at (100.0, 120.0, 150.0) in the world coordinate frame with radius
10.0. Again, we assume that the radius is specified in the chosen
unit of measurement, yet to be discussed.

@<Read sphere geometry from a file@>=
fscanf(f, "(sphere \"%[^\"]\" %lf %lf %lf %lf)\n",
       p->name, &p->origin.x, &p->origin.y, &p->origin.z,
       &p->radius);

@*2 Cylinder.
A primitive cylinder stores the following information.

@<Structure of a primitive cylinder@>=
struct primitive_cylinder_struct {
       @<Information common to all primitives@>;
       @<Information that defines a primitive cylinder@>;
};
typedef struct primitive_cylinder_struct Cylinder;

@ The geometry of a cylinder is defined by its base radius and its
height.  The origin of the block's local coordinate frame is defined by
its {\it centroid}@^centroid@>, and the orthogonal axes incident on
this origin, i.e., the $x$, $y$ and $z$ axes of the local coordinate
frame, are aligned so that $y$ axis is perpendicular to the base.

@<Information that defines a primitive cylinder@>=
double radius, height;

@ The parameters for the cylinder geometry are supplied in the following
format.

\smallskip

({\bf cylinder} ``name" $x$ $y$ $z$ $radius$ $height$)

\smallskip

For instance, the specification {\tt (cylinder "Cylinder A" 100.0 120.0
150.0 10.0 20.0)} initialises a new solid cylinder named ``Cylinder A"
located at (100.0, 120.0, 150.0) in the world coordinate frame with
base radius 10.0 and height 20.0.

@<Read cylinder geometry from a file@>=
fscanf(f, "(cylinder \"%[^\"]\" %lf %lf %lf %lf)\n",
       p->name, &p->origin.x, &p->origin.y, &p->origin.z,
       &p->radius, &p->height);

@*2 Torus.
A primitive torus stores the following information.

@<Structure of a primitive torus@>=
struct primitive_torus_struct {
       @<Information common to all primitives@>;
       @<Information that defines a primitive torus@>;
};
typedef struct primitive_torus_struct Torus;

@ The geometry of a primitive torus can be defined parametrically as
follows:

\halign{\hfil $#$ & $#$ & $#$ \hfil \cr
    x(u, v) & = & (R + r \cos{v}) \cos{u} \cr
    y(u, v) & = & (R + r \cos{v}) \sin{u} \cr
    z(u, v) & = & r \sin{v} \cr}

\noindent where, parameters $u$ and $v$ specify angles in radians such
that $0 \le u, v < 2\pi$. The length $R$ gives the distance from the
center of the tube to the center of the torus, and the length $r$
gives the radius of the tube. The parameters $R$ and $r$ are also
referred to as the {\it major radius}@^major radius@> and the {\it
minor radius}@^minor radius@>, respecticely; and their ratio is
referred to as the {\it aspect ratio}@^aspect ratio@>.

The origin of the torus' local coordinate frame is defined by
its {\it center}@^center@>, and the orthogonal axes incident on
this origin are aligned so that its $y$ axis is perpendicular to the
radial surface emanating from the origin to the center of the tube.

@<Information that defines a primitive torus@>=
double major, minor;
double u, v;

@ The parameters for the torus geometry are supplied in the following
format.

\smallskip

({\bf torus} ``name" $x$ $y$ $z$ $u$ $v$ $major$ $minor$)

\smallskip

For instance, the specification {\tt (torus "Torus A" 100.0 120.0
150.0 0.0 359.999999 10.0 2.0)} initialises a solid torus named
``Torus A" located at (100.0, 120.0, 150.0) in the world coordinate
frame with major radius 10.0 and minor 2.0. Note here that $v < 2\pi$.

@<Read torus geometry from a file@>=
fscanf(f, "(torus \"%[^\"]\" %lf %lf %lf %lf %lf %lf %lf)\n",
       p->name, &p->origin.x, &p->origin.y, &p->origin.z,
       &p->u, &p->v, &p->major, &p->minor);

@** Error handling.
There are three message categories, which are printed using the
following macros: |fatal|, |warn|, and |info|.

@d fatal(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d warn(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);
@d info(X) fprintf(stderr, "%s[%5d] %s\n", __FILE__, __LINE__, X);

@ @<Include system libraries@>=
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

@ @<Global variables@>=
uint32_t i, j, k, l, m, n; /* counters */
Event *current_event = NULL;
Vertex *current_vertex = NULL;
Particle *current_particle = NULL;
uint32_t num_events = 5;
uint32_t num_vertices = 5;
uint32_t num_particles = 5;
Particle_gun particle_gun;
Particle_stack particle_stack;
vect3d zero_vector = { 0.0, 0.0, 0.0 };

@ @<Global data structures@>=
@<Definition of a three-dimensional vector@>;
@<Definition of a physics particle@>;
@<Definition of a vertex@>;
@<Definition of an event@>;
@<Definition of a particle gun@>;
@<Definition of a stack@>;
@<Structure of a primitive block@>;
@<Structure of a primitive sphere@>;
@<Structure of a primitive cylinder@>;
@<Structure of a primitive torus@>;

@ @<Global functions@>=
@<Calculate vector magnitude@>;
@<Normalise a vector@>;
@<Create particle@>;
@<Create vertex@>;
@<Create event@>;
@<Destroy particle@>;
@<Destroy vertex@>;
@<Destroy event@>;
@<Reset the particle gun@>;
@<Set num particles to be generated by particle gun@>;
@<Set position of particle gun@>;
@<Set momentum of particle gun@>;
@<Set polarisation of particle gun@>;
@<Set energy of particle gun@>;
@<Set charge of particle gun@>;
@<Print particle tree@>;
@<Print vertex tree@>;
@<Print event tree@>;
@<Push particle into particle stack@>;
@<Pop particle out of the particle stack@>;
@<Tracking a particle@>;
@<Read block geometry from a file@>;

@* History.
The {\it Monte Carlo Simulator} project began in June 2011, when
Dr.~Gagarine Yaikhom was a WIMCS Research Fellow under Prof.~David
W. Walker at Cardiff University. The initial aim of the project was to
port the Geant4 system to run on CUDA GPUs. However, after studying
the Geant4 code-base, we concluded that it will be prohibitive to port
the entire Geant4 system given the short duration of the funding (8
months, from June 2011 until January 2012) and that only Dr.~Yaikhom
will be carrying out the design and implementation. We, therefore,
decided to use the Geant4 system only as a guideline system
architecture, and to reimplement the performance-intensive concepts
and their dependencies for a simplified simulator. This
implementation, which began on 5 August 2011, uses data structures
and algorithms that are more appropriate for eventual multithreaded
parallelisation on GPUs.

@**Index.

